{"entries":[{"timestamp":1759349373594,"editorVersion":"2.0.58","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":206,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1759349381569,"editorVersion":"2.0.58","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1759356178297,"editorVersion":"2.0.58","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":177,"length1":42,"diffs":[[1,"        \"assets.json\"\n"]]}]},{"type":"added","filename":"types.ts","value":""}]},{"timestamp":1759356628276,"editorVersion":"2.0.58","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":0,"length1":1068,"diffs":[[1,""]]}]}]},{"timestamp":1759356790444,"editorVersion":"2.0.58","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":1067,"length1":628,"diffs":[[1,""]]}]}]},{"timestamp":1759357368780,"editorVersion":"2.0.58","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":371,"length1":85,"diffs":[[1,"        static fromTuple([x, y]: [number, number]) {\n"]]},{"start1":1695,"length1":965,"diffs":[[1,""]]}]}]},{"timestamp":1759357976970,"editorVersion":"2.0.58","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":2135,"length1":0,"diffs":[[1,"        console.log(u.resolution[0])\n"]]}]}]},{"timestamp":1759357978599,"editorVersion":"2.0.58","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":2449,"length1":36,"diffs":[[1,"            resolution: [screen.width, screen.height],\n"]]}]}]},{"timestamp":1759434361815,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1759434389071,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":52,"length1":26,"diffs":[[1,"        resolution: [number, number];\n"]]},{"start1":135,"length1":22,"diffs":[[1,"        mouse?: [number, number];\n"]]},{"start1":285,"length1":112,"diffs":[[1,"    export class Vec2 {\n"]]},{"start1":2359,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1759434973361,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":261,"length1":30,"diffs":[[1,"    export interface vec2 {\n"]]}]}]},{"timestamp":1759440128656,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":261,"length1":31,"diffs":[[1,"    export interface vec2<> {\n"]]}]}]},{"timestamp":1759440133590,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":52,"length1":26,"diffs":[[1,"        resolution: vec2;\n"]]},{"start1":123,"length1":22,"diffs":[[1,"        mouse?: vec2;\n"]]},{"start1":179,"length1":25,"diffs":[[1,"        fragCoord: [number, number],\n"]]},{"start1":292,"length1":27,"diffs":[[1,"        x: number,\n        y: number\n"]]},{"start1":336,"length1":48,"diffs":[[1,"    export class Vec2 implements vec2 {\n"]]},{"start1":437,"length1":0,"diffs":[[1,"        static fromTuple(tuple: [number, number]) {\n            const [x, y] = tuple\n            return new Vec2(x, y);\n        }\n\n"]]},{"start1":1093,"length1":0,"diffs":[[1,"\n        toTuple(): [number, number] { return [this.x, this.y]; }\n"]]},{"start1":1897,"length1":184,"diffs":[[1,"        const [w, h] = uniforms.resolution;\n\n        for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n                const color = shader([x, y], uniforms);\n"]]},{"start1":2201,"length1":86,"diffs":[[1,"        const x = frag[0] / u.resolution[0];\n        const y = frag[1] / u.resolution[1];\n"]]},{"start1":2365,"length1":30,"diffs":[[1,"        return v > 0 ? 7 : 2; // pick palette colors\n"]]},{"start1":2514,"length1":104,"diffs":[[1,"            resolution: [160, 120],\n            time: game.runtime() / 1000, // seconds\n"]]}]}]},{"timestamp":1759441096854,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":2422,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1759441273017,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":2153,"length1":60,"diffs":[[1,"        return v > 0 ? 7 : 2;\n"]]},{"start1":2191,"length1":42,"diffs":[[1,""]]},{"start1":2422,"length1":52,"diffs":[[1,""]]},{"start1":2423,"length1":41,"diffs":[[1,"        runShader(exampleShader, screen, uniforms);\n"]]}]}]},{"timestamp":1759441617567,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":200,"length1":43,"diffs":[[1,"        \"types.ts\"\n"]]},{"start1":226,"length1":358,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"types.ts","patch":[{"start1":1582,"length1":0,"diffs":[[1,"\n    function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const color = shader(new Vec2(x, y), uniforms);\n                img.setPixel(x, y, color);\n            }\n        }\n    }\n\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? game.Color.Yellow : game.Color.Blue;\n    };\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    game.onUpdate(function () {\n        const uniforms: Uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        runShader(exampleShader, screen, uniforms);\n\n        scene.setBackgroundImage(screen)\n    });\n"]]}]},{"type":"added","filename":"functions.ts","value":"namespace Shaders {\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const color = shader(new Vec2(x, y), uniforms);\n                img.setPixel(x, y, color);\n            }\n        }\n    }\n\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? game.Color.Yellow : game.Color.Blue;\n    };\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    \n    game.onUpdate(function () {\n        const uniforms: Uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        runShader(exampleShader, screen, uniforms);\n\n        scene.setBackgroundImage(screen)\n    });\n}"}]},{"timestamp":1759505297264,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":249,"length1":6,"diffs":[[1,""]]}]}]},{"timestamp":1759505302154,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":249,"length1":57,"diffs":[[1,"    \n"]]},{"start1":255,"length1":270,"diffs":[[1,""]]}]},{"type":"edited","filename":"functions.ts","patch":[{"start1":388,"length1":31,"diffs":[[1,""]]}]}]},{"timestamp":1759505879012,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"types.ts","patch":[{"start1":231,"length1":16,"diffs":[[1,"    ) => number;\n"]]},{"start1":349,"length1":88,"diffs":[[1,""]]},{"start1":396,"length1":383,"diffs":[[1,""]]},{"start1":449,"length1":192,"diffs":[[1,"            const shade = luminance == 1 ? 15 : Math.floor(luminance * 16)\n            return new Color(shade)\n"]]},{"start1":570,"length1":115,"diffs":[[1,""]]}]},{"type":"edited","filename":"functions.ts","patch":[{"start1":314,"length1":49,"diffs":[[1,"                img.setPixel(x, y, color);\n"]]},{"start1":388,"length1":0,"diffs":[[1,"    export function colorFrom\n\n"]]},{"start1":628,"length1":68,"diffs":[[1,"        return v > 0 ? game.Color.Yellow : game.Color.Blue;\n"]]}]}]},{"timestamp":1759506477246,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":155,"diffs":[[1,""]]},{"start1":1,"length1":281,"diffs":[[1,""]]}]},{"type":"edited","filename":"types.ts","patch":[{"start1":733,"length1":40,"diffs":[[1,"                const shade = 16 - raw; // invert so 0=black, 1=white\n"]]},{"start1":919,"length1":154,"diffs":[[1,"            const clamped = Math.max(0, Math.min(1, luminance));\n            const raw = Math.floor(clamped * 14) + 1;\n            const shade = 16 - raw;\n            return new Color(shade);\n"]]}]},{"type":"edited","filename":"functions.ts","patch":[{"start1":20,"length1":78,"diffs":[[1,""]]},{"start1":394,"length1":211,"diffs":[[1,"    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? Color.fromFloat(0.2) : Color.fromFloat(0.8);\n"]]},{"start1":679,"length1":76,"diffs":[[1,"    const screen = image.create(160, 120)\n    let frame = 0;\n"]]},{"start1":777,"length1":21,"diffs":[[1,"        const uniforms: Uniforms = {\n"]]},{"start1":957,"length1":0,"diffs":[[1,"        runShader(exampleShader, screen, uniforms);\n\n"]]},{"start1":1059,"length1":57,"diffs":[[1,""]]}]}]},{"timestamp":1759507313404,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"types.ts","patch":[{"start1":248,"length1":120,"diffs":[[1,""]]}]}]},{"timestamp":1759507317709,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":305,"length1":642,"diffs":[[1,"    game.onUpdate(() => {\n        runShader(exampleShader, screen, getUniforms());\n        scene.setBackgroundImage(screen)\n"]]}]},{"type":"edited","filename":"types.ts","patch":[{"start1":152,"length1":75,"diffs":[[1,""]]},{"start1":248,"length1":0,"diffs":[[1,"    export type MainProgram = (uniforms: Uniforms, target: Image) => void;\n\n    let activeProgram: MainProgram = null;\n\n"]]}]},{"type":"edited","filename":"functions.ts","patch":[{"start1":98,"length1":62,"diffs":[[1,""]]},{"start1":691,"length1":147,"diffs":[[1,"    export function getUniforms(): Uniforms {\n        return uniforms\n"]]},{"start1":772,"length1":26,"diffs":[[1,"    game.onUpdate(function () {\n"]]},{"start1":968,"length1":84,"diffs":[[1,""]]},{"start1":1009,"length1":7,"diffs":[[1,"    });\n\n    export function attachLoop(): void {\n        \n    }\n"]]}]}]},{"timestamp":1759507914196,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":229,"length1":34,"diffs":[[1,"        return v > 0 ? Color.fromFloat(0.2) : Color.fromFloat(0.8);\n"]]},{"start1":830,"length1":203,"diffs":[[1,""]]},{"start1":831,"length1":1161,"diffs":[[1,""]]},{"start1":895,"length1":52,"diffs":[[1,"        runShader(exampleShader, screen, uniforms);\n"]]}]},{"type":"edited","filename":"types.ts","patch":[{"start1":306,"length1":17,"diffs":[[1,"    ) => Color;\n"]]}]},{"type":"edited","filename":"functions.ts","patch":[{"start1":390,"length1":125,"diffs":[[1,"                const color = shader(new Vec2(x, y), uniforms);\n"]]}]}]},{"timestamp":1759508546366,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2161,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1759508559724,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2160,"length1":144,"diffs":[[1,""]]},{"start1":2161,"length1":101,"diffs":[[1,""]]},{"start1":2162,"length1":2096,"diffs":[[1,""]]},{"start1":2226,"length1":55,"diffs":[[1,"        runShader(circlesShader, screen, uniforms);\n"]]}]}]},{"timestamp":1759509155960,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4029,"length1":266,"diffs":[[1,"    const checkersWithRipple: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n"]]},{"start1":4172,"length1":285,"diffs":[[1,"        const v = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n      \n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n"]]},{"start1":4333,"length1":173,"diffs":[[1,"        // marble pattern\n        const v = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n"]]},{"start1":4434,"length1":1103,"diffs":[[1,"        // normalize to 0..1\n        return (v + 1.0) * 0.5;\n"]]},{"start1":4567,"length1":56,"diffs":[[1,"        runShader(marbleWithRipple, screen, uniforms);\n"]]}]}]},{"timestamp":1759509742471,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4029,"length1":99,"diffs":[[1,"    // 0/1 checker in UV space\n    function checker01(uvx: number, uvy: number, scale = 10): number {\n        const cx = Math.floor(uvx * scale);\n        const cy = Math.floor(uvy * scale);\n        return ((cx + cy) & 1) ? 1 : 0; // 1=white tile, 0=black tile\n    }\n\n    // radial ripple, returns ~[-1, 1] with distance damping\n    function radialRipple(frag: Shaders.Vec2, u: Shaders.Uniforms): number {\n"]]},{"start1":4582,"length1":230,"diffs":[[1,"        const freq = 0.12;      // ring spacing\n        const speed = 3.0;      // animation speed\n        const damping = 1.0 / (1.0 + dist * 0.06); // fades with distance\n"]]},{"start1":4756,"length1":53,"diffs":[[1,"        return Math.sin(dist * freq - u.time * speed) * damping; // [-1,1]*damp\n    }\n\n    // ✔ Additive lighting: keeps the board, makes BOTH colors shimmer\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n"]]},{"start1":5020,"length1":43,"diffs":[[1,"        const uvy = frag.y / u.resolution.y;\n"]]},{"start1":5066,"length1":149,"diffs":[[1,"        // Choose base luminance per tile (don't use pure 0/1 so we have headroom)\n        const t = checker01(uvx, uvy, 10); // 0 or 1\n        const blackLevel = 0.40;           // how dark black tiles are\n        const whiteLevel = 0.60;           // how bright white tiles are\n        const base = blackLevel * (1 - t) + whiteLevel * t; // mix\n"]]},{"start1":5414,"length1":203,"diffs":[[1,"        // Ripple adds/subtracts brightness equally for both colors\n        const amp = 0.5;                  // ripple strength\n        \n        const contrast = 0.9; // 0..1 (how strong the checker contrast is)\n        const baseHC = 0.5 + (t - 0.5) * contrast;       // keeps board punchy\n        const luminance = Math.max(0, Math.min(1, baseHC + amp * radialRipple(frag, u)));\n"]]},{"start1":5797,"length1":371,"diffs":[[1,"        return luminance; // 0..1; your backend maps to 1..15\n"]]}]}]},{"timestamp":1759510233059,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4029,"length1":140,"diffs":[[1,""]]},{"start1":4090,"length1":35,"diffs":[[1,"        // --- radial ripple math ---\n"]]},{"start1":4276,"length1":237,"diffs":[[1,"        const freq = 0.12;                   // ripple spacing\n        const speed = 3.0;                   // animation speed\n        const damping = 1.0 / (1.0 + dist * 0.06);\n        const phase = dist * freq - u.time * speed;\n"]]},{"start1":4507,"length1":1215,"diffs":[[1,"        // --- UV distortion (warp checkerboard) ---\n"]]},{"start1":4649,"length1":56,"diffs":[[1,"        const warpAmp = 0.05;\n        const wave = Math.sin(phase);        // << use the SAME wave for both\n        uvy += wave * warpAmp * damping;\n"]]},{"start1":4799,"length1":58,"diffs":[[1,"        // --- checkerboard pattern ---\n        const tiles = 10;\n"]]},{"start1":5003,"length1":108,"diffs":[[1,"        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n"]]},{"start1":5120,"length1":112,"diffs":[[1,"        // --- shimmer tied to same wave ---\n        const shimmerAmp = 0.25;\n        const shimmer = wave * shimmerAmp * damping;\n"]]},{"start1":5252,"length1":22,"diffs":[[1,"        // combine\n        let L = base + shimmer;\n"]]},{"start1":5356,"length1":55,"diffs":[[1,"        return L;\n"]]},{"start1":5382,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1759510737551,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4230,"length1":143,"diffs":[[1,"        // ----- coordinates -----\n"]]},{"start1":4413,"length1":440,"diffs":[[1,"        // ----- knobs (edit freely) -----\n        const tiles = 10;            // checker scale\n        const blackLevel = 0.10;     // base luminance of black tiles\n        const whiteLevel = 0.90;     // base luminance of white tiles\n"]]},{"start1":4651,"length1":141,"diffs":[[1,"        const freq = 0.3;           // ripple ring spacing\n        const speed = 3.0;           // ripple animation speed\n        const dampingK = 0.1;       // ripple falloff (bigger → fades faster)\n\n        const warpAmp = 0.05;        // geometric wobble amplitude (px in UV space)\n        const shimmerAmp = 0.25;     // brightness modulation amplitude\n\n        // Independent phase offsets (radians). Try 0, ±Math.PI/2, Math.PI, etc.\n        const warpPhaseOffset = 0;\n        const shimmerPhaseOffset = -Math.PI;\n\n        // If Y feels inverted, flip the sign here (or just make warpAmp negative).\n        const warpSign = -1.0;\n\n        // ----- base phase, damping -----\n        const basePhase = dist * freq - u.time * speed;\n        const damping = 1.0 / (1.0 + dist * dampingK);\n\n        // ----- choose the waves (swap sin/cos or multiply by -1 to test) -----\n        const warpPhase = basePhase + warpPhaseOffset;\n        const shimmerPhase = basePhase + shimmerPhaseOffset;\n\n        const warpWave = Math.sin(warpPhase);     // try Math.cos(...) or -Math.sin(...)\n        const shimmerWave = Math.sin(shimmerPhase);  // try Math.cos(...) or -Math.sin(...)\n\n        // ----- build UVs, then warp -----\n"]]},{"start1":5955,"length1":256,"diffs":[[1,"        uvy += warpSign * warpWave * warpAmp * damping;\n"]]},{"start1":6012,"length1":428,"diffs":[[1,"        // ----- checkerboard sampled on WARPED UVs -----\n        const tx = Math.floor(uvx * tiles);\n        const ty = Math.floor(uvy * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n"]]},{"start1":6208,"length1":194,"diffs":[[1,"        // base luminance with headroom for shimmer\n        const base = isWhite ? whiteLevel : blackLevel;\n"]]},{"start1":6317,"length1":797,"diffs":[[1,"        // ----- shimmer tied to its own phase -----\n        let L = base + shimmerWave * shimmerAmp * damping;\n"]]},{"start1":6430,"length1":201,"diffs":[[1,"        // clamp 0..1\n"]]},{"start1":6505,"length1":18,"diffs":[[1,"        return L; // backend maps to grayscale indices\n"]]}]}]},{"timestamp":1759511360768,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":6722,"length1":142,"diffs":[[1,"        // const shimmerPhase = (uvy * u.resolution.y) * freq - u.time * speed;\n        // const shimmer = Math.sin(shimmerPhase) * 0.25 * damping;\n"]]}]}]},{"timestamp":1759511424568,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":4230,"length1":50,"diffs":[[1,"        // --------------------------------------\n        // 1. Compute distance from center\n        // --------------------------------------\n"]]},{"start1":4521,"length1":108,"diffs":[[1,"        // --------------------------------------\n        // 2. Ripple parameters\n        // --------------------------------------\n        const freq = 0.12;                   // spacing between ripple rings\n"]]},{"start1":4794,"length1":103,"diffs":[[1,"        const damping = 1.0 / (1.0 + dist * 0.06); // fade amplitude with distance\n        const phase = dist * freq - u.time * speed; // base phase for radial ripple\n"]]},{"start1":4962,"length1":53,"diffs":[[1,"        // --------------------------------------\n        // 3. Position ripple (warp UVs)\n        // --------------------------------------\n"]]},{"start1":5192,"length1":109,"diffs":[[1,"        const warpAmp = 0.05;                // amount of vertical wobble\n        const wave = Math.clamp(-1.0, 1.0, Math.sin(phase));        // wave used for position ripple\n        uvy += wave * warpAmp * damping;     // warp the checkerboard vertically\n"]]},{"start1":5449,"length1":230,"diffs":[[1,"        // --------------------------------------\n        // 4. Checkerboard pattern\n        // --------------------------------------\n        const tiles = 10;                    // number of tiles across screen\n        const tx = Math.floor(uvx * tiles);  // tile x index\n        const ty = Math.floor(uvy * tiles);  // tile y index (after warping!)\n        const isWhite = ((tx + ty) & 1) ? 1 : 0; // alternating 0/1 pattern\n"]]},{"start1":5878,"length1":0,"diffs":[[1,"        // base luminance values (not pure 0/1 to leave headroom for shimmer)\n"]]},{"start1":6073,"length1":238,"diffs":[[1,"        // --------------------------------------\n        // 5. Brightness ripple (shimmer)\n        // --------------------------------------\n        // IDEA: shimmer should *move with* the position ripple.\n        // - If you base shimmer on dist: you'll get concentric horizontal lines.\n        // - If you base shimmer on warped UVs: shimmer will \"stick\" to the checker warp.\n        // Try swapping between these options:\n        //\n        // Option A: shimmer from radial distance (may cause horizontal banding)\n        const shimmer = wave * 0.25 * damping;\n        //\n        // Option B: shimmer from warped UV.y (follows checker movement)\n        const shimmerPhase = (uvy * u.resolution.y) * freq - u.time * speed;\n        const shimmer = Math.sin(shimmerPhase) * 0.25 * damping;\n"]]},{"start1":6865,"length1":232,"diffs":[[1,"        // --------------------------------------\n        // 6. Combine base + shimmer\n        // --------------------------------------\n"]]},{"start1":7034,"length1":0,"diffs":[[1,"\n        // clamp to 0..1 range\n"]]},{"start1":7145,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1759511935404,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5886,"length1":2123,"diffs":[[1,""]]},{"start1":5950,"length1":61,"diffs":[[1,"        runShader(checkerWithRipple, screen, uniforms);\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":70,"length1":53,"diffs":[[1,"        \"device\": \"*\"\n"]]}]}]},{"timestamp":1759512614884,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":5909,"length1":141,"diffs":[[1,"        origin: Shaders.Vec2;   // position in screen coords\n        startTime: number;      // when it was created\n"]]},{"start1":6032,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1759512631757,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":6057,"length1":0,"diffs":[[1,"\n"]]},{"start1":6479,"length1":196,"diffs":[[1,""]]},{"start1":6488,"length1":73,"diffs":[[1,"    function rippleContribution(frag: Shaders.Vec2, r: Ripple, u: Shaders.Uniforms): number {\n"]]},{"start1":6662,"length1":41,"diffs":[[1,"        const dist = Math.sqrt(dx * dx + dy * dy);\n"]]},{"start1":6714,"length1":122,"diffs":[[1,"        const age = u.time - r.startTime;\n        if (age < 0) return 0;\n"]]},{"start1":6788,"length1":90,"diffs":[[1,"        const speed = 40;   // px per second\n        const freq = 0.25;  // wave frequency\n        const falloff = 0.05;\n"]]},{"start1":6910,"length1":115,"diffs":[[1,"        // position of the wavefront\n        const waveDist = age * speed;\n"]]},{"start1":6986,"length1":133,"diffs":[[1,"        // how close this pixel is to the current wavefront\n        const diff = dist - waveDist;\n\n        // sharpness of the ring\n        const ring = Math.exp(-diff * diff * 0.05);\n\n        // oscillating ripple with distance damping\n        return Math.sin(dist * freq - age * 4) * ring * (1 / (1 + dist * falloff));\n"]]},{"start1":7380,"length1":37,"diffs":[[1,"        // checkerboard base\n"]]},{"start1":7705,"length1":51,"diffs":[[1,"        // add ripples\n"]]},{"start1":7755,"length1":123,"diffs":[[1,"        for (const r of ripples) {\n            rippleSum += rippleContribution(frag, r, u);\n"]]},{"start1":7858,"length1":76,"diffs":[[1,"        // combine (tune ripple weight)\n        let L = base + rippleSum * 0.3;\n"]]},{"start1":8035,"length1":139,"diffs":[[1,"    initDefaults()\n    setActiveProgram((uniforms, screen) => {\n        runShader(checkerWithRippleClick, screen, uniforms);\n    })\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":251,"length1":47,"diffs":[[1,"        \"functions.ts\"\n"]]}]},{"type":"added","filename":"water_sim.ts","value":"namespace WaterSim {\n    export const GW = 64;\n    export const GH = 48;\n    const FP = 256;\n\n    // Damping\n    const DAMP_NUM = 220;\n    const DAMP_SHIFT = 8;\n\n    // Pre-allocate buffers as plain number[] with fixed size\n    const SIZE = GW * GH;\n    let A: number[] = [];\n    let B: number[] = [];\n    let C: number[] = [];\n\n    // Manual initialization (no `new Array`)\n    export function init() {\n        A = [];\n        B = [];\n        C = [];\n        for (let i = 0; i < SIZE; i++) {\n            A.push(0);\n            B.push(0);\n            C.push(0);\n        }\n    }\n\n    let prev: number[];\n    let cur: number[];\n    let nextB: number[];\n\n    export function reset() {\n        init();\n        prev = A;\n        cur = B;\n        nextB = C;\n    }\n\n    function idx(x: number, y: number) { return y * GW + x; }\n\n    // Splash at screen coords\n    export function splash(sx: number, sy: number, strength = 1, radiusPx = 10) {\n        const gx = Math.idiv(sx * GW, screen.width);\n        const gy = Math.idiv(sy * GH, screen.height);\n        const r = Math.max(1, Math.idiv(radiusPx * GW, screen.width));\n\n        const amp = (strength * FP) | 0;\n\n        for (let y = Math.max(1, gy - r); y <= Math.min(GH - 2, gy + r); y++) {\n            for (let x = Math.max(1, gx - r); x <= Math.min(GW - 2, gx + r); x++) {\n                const dx = x - gx;\n                const dy = y - gy;\n                const d2 = dx * dx + dy * dy;\n                if (d2 <= r * r) {\n                    cur[idx(x, y)] += amp;\n                }\n            }\n        }\n    }\n\n    export function step() {\n        for (let y = 1; y < GH - 1; y++) {\n            const yW = y * GW;\n            for (let x = 1; x < GW - 1; x++) {\n                const i = yW + x;\n                const sum = cur[i - 1] + cur[i + 1] + cur[i - GW] + cur[i + GW];\n                let n = (sum >> 1) - prev[i];\n                n = (n * DAMP_NUM) >> DAMP_SHIFT;\n                nextB[i] = n;\n            }\n        }\n        // rotate\n        const tmp = prev; prev = cur; cur = nextB; nextB = tmp;\n    }\n\n    export function sampleHeight(sx: number, sy: number): number {\n        const gx = sx * (GW - 1) / (screen.width - 1);\n        const gy = sy * (GH - 1) / (screen.height - 1);\n\n        const x0 = Math.max(0, Math.min(GW - 2, Math.floor(gx)));\n        const y0 = Math.max(0, Math.min(GH - 2, Math.floor(gy)));\n        const tx = gx - x0;\n        const ty = gy - y0;\n\n        const i00 = cur[idx(x0, y0)];\n        const i10 = cur[idx(x0 + 1, y0)];\n        const i01 = cur[idx(x0, y0 + 1)];\n        const i11 = cur[idx(x0 + 1, y0 + 1)];\n\n        const a = i00 * (1 - tx) + i10 * tx;\n        const b = i01 * (1 - tx) + i11 * tx;\n        const hFP = a * (1 - ty) + b * ty;\n\n        return (hFP / FP) / 2;\n    }\n}\n\nWaterSim.reset();\n\nbrowserEvents.MouseAny.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n    WaterSim.splash(x, y, 1.0, 4);\n});\n\ngame.onUpdate(function () {\n    WaterSim.step();\n});\n\nconst checkerWaterShader: Shaders.Shader = (frag, u) => {\n    const h = WaterSim.sampleHeight(frag.x, frag.y);\n\n    const uvx = frag.x / u.resolution.x;\n    let uvy = frag.y / u.resolution.y + h * 0.15;\n\n    const tiles = 10;\n    const tx = Math.floor(uvx * tiles);\n    const ty = Math.floor(uvy * tiles);\n    const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n    let L = isWhite ? 0.9 : 0.1;\n    L += h * 0.5;\n\n    if (L < 0) L = 0;\n    if (L > 1) L = 1;\n\n    return L;\n};\n\nShaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})"}]},{"timestamp":1759513217716,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":21,"length1":52,"diffs":[[1,"    export const GW = 64;\n    export const GH = 48;\n"]]},{"start1":109,"length1":26,"diffs":[[1,"    const DAMP_NUM = 220;\n"]]},{"start1":2797,"length1":97,"diffs":[[1,""]]}]}]},{"timestamp":1759513512861,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":2856,"length1":92,"diffs":[[1,"    WaterSim.splash(x, y, 0.1, 4);\n"]]},{"start1":2894,"length1":0,"diffs":[[1,"browserEvents.MouseAny.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n    WaterSim.splash(x, y, 1.0, 4);\n});\n"]]}]}]},{"timestamp":1759522308506,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":2797,"length1":3,"diffs":[[1,""]]}]}]},{"timestamp":1759522334386,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":11193,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"10\" y=\"10\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":488,"length1":18,"diffs":[[1,"        const v =\n"]]},{"start1":679,"length1":40,"diffs":[[1,"        const normalized = (v + 3) / 6;\n"]]},{"start1":1000,"length1":94,"diffs":[[1,"        const v = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized = (v + 1) / 2;\n"]]},{"start1":1094,"length1":28,"diffs":[[1,"        return normalized;\n"]]},{"start1":1185,"length1":136,"diffs":[[1,"        const nx = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny = (frag.y - u.resolution.y / 2) / u.resolution.y;\n"]]},{"start1":1320,"length1":100,"diffs":[[1,"        const angle = Math.atan2(ny, nx);\n        const dist = Math.sqrt(nx * nx + ny * ny);\n"]]},{"start1":1414,"length1":93,"diffs":[[1,"        const v = Math.sin(10 * dist - u.time * 3 + angle * 5);\n        return (v + 1) / 2;\n"]]},{"start1":1652,"length1":111,"diffs":[[1,"        const v = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return v ? 1.0 : 0.0;\n"]]},{"start1":1828,"length1":128,"diffs":[[1,"        const cx = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy = u.resolution.y / 2 + Math.cos(u.time) * 30;\n"]]},{"start1":1955,"length1":118,"diffs":[[1,"        const dx = frag.x - cx;\n        const dy = frag.y - cy;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n"]]},{"start1":2071,"length1":82,"diffs":[[1,"        const v = Math.sin(dist * 0.2 - u.time * 2);\n        return (v + 1) / 2;\n"]]},{"start1":2216,"length1":90,"diffs":[[1,"        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n"]]},{"start1":2305,"length1":96,"diffs":[[1,"        const v = Math.sin(nx * 10 + Math.sin(ny * 10 + u.time));\n        return (v + 1) / 2;\n"]]},{"start1":2699,"length1":72,"diffs":[[1,"        const v = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n"]]},{"start1":2823,"length1":32,"diffs":[[1,"        return (v + 1.0) * 0.5;\n"]]},{"start1":2969,"length1":154,"diffs":[[1,"        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n"]]},{"start1":3341,"length1":68,"diffs":[[1,"        const damping = 1.0 / (1.0 + dist * 0.01); // tweak factor\n"]]},{"start1":3409,"length1":84,"diffs":[[1,"        const offset = Math.sin(dist * freq - u.time * speed) * baseAmp * damping;\n"]]},{"start1":3519,"length1":90,"diffs":[[1,"        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n"]]},{"start1":3652,"length1":24,"diffs":[[1,"        uvy += offset;\n"]]},{"start1":3676,"length1":45,"diffs":[[1,"        return new Shaders.Vec2(uvx, uvy);\n"]]},{"start1":3885,"length1":74,"diffs":[[1,"        const v = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n"]]},{"start1":3989,"length1":32,"diffs":[[1,"        return (v + 1.0) * 0.5;\n"]]},{"start1":4280,"length1":154,"diffs":[[1,"        const dx = frag.x - u.resolution.x / 2;\n        const dy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n"]]},{"start1":4473,"length1":237,"diffs":[[1,"        const freq = 0.12;                   // ripple spacing\n        const speed = 3.0;                   // animation speed\n        const damping = 1.0 / (1.0 + dist * 0.06);\n        const phase = dist * freq - u.time * speed;\n"]]},{"start1":4757,"length1":90,"diffs":[[1,"        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n"]]},{"start1":4914,"length1":43,"diffs":[[1,"        uvy += wave * warpAmp * damping;\n"]]},{"start1":5049,"length1":90,"diffs":[[1,"        const tx = Math.floor(uvx * tiles);\n        const ty = Math.floor(uvy * tiles);\n"]]},{"start1":5367,"length1":182,"diffs":[[1,"        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = (uvy * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n"]]},{"start1":5605,"length1":132,"diffs":[[1,"        const shimmerPhase = distWarped * freq - u.time * speed;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping;\n"]]},{"start1":6756,"length1":128,"diffs":[[1,"        const dx = frag.x - r.origin.x;\n        const dy = frag.y - r.origin.y;\n        const dist2 = dx * dx + dy * dy;\n"]]},{"start1":6878,"length1":125,"diffs":[[1,"        const dist = Math.sqrt(dist2); // one sqrt only if near the ripple\n        const diff = dist - (r.waveDist || 0);\n"]]},{"start1":7271,"length1":71,"diffs":[[1,"        return Math.sin(dist * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n"]]},{"start1":7451,"length1":309,"diffs":[[1,"        const uvx = frag.x / u.resolution.x;\n        const uvy = frag.y / u.resolution.y;\n        const scale = 10;\n        const tx = Math.floor(uvx * scale);\n        const ty = Math.floor(uvy * scale);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n        const base = isWhite ? 0.9 : 0.1;\n"]]},{"start1":8001,"length1":36,"diffs":[[1,"        let L = base + rippleSum;\n"]]},{"start1":8053,"length1":56,"diffs":[[1,"        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n"]]},{"start1":8106,"length1":19,"diffs":[[1,"        return L;\n"]]},{"start1":8271,"length1":2,"diffs":[[1,"}"]]}]},{"type":"edited","filename":"water_sim.ts","patch":[{"start1":2797,"length1":81,"diffs":[[1,""]]},{"start1":2798,"length1":0,"diffs":[[1,"\n\n"]]},{"start1":2859,"length1":32,"diffs":[[1,""]]},{"start1":2906,"length1":65,"diffs":[[1,"        WaterSim.splash(x, y, 1.0, 4);\n"]]},{"start1":3004,"length1":102,"diffs":[[1,""]]}]}]},{"timestamp":1759523007104,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":3715,"length1":147,"diffs":[[1,"Shaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})"]]}]}]},{"timestamp":1759523270051,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":275,"length1":71,"diffs":[[1,"        \"water_sim.ts\"\n"]]}]},{"type":"edited","filename":"water_sim.ts","patch":[{"start1":3715,"length1":135,"diffs":[[1,"// Shaders.initDefaults()\n// Shaders.setActiveProgram((uniforms, screen) => {\n//     Shaders.runShader(checkerWaterShader, screen, uniforms);\n// })"]]}]},{"type":"added","filename":"images.g.jres","value":"{\n    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7u4AAM6qqqqqig7grKqqqqqKDuCs7qqq7ooO4Kzuqqruig7gqqqqqqqKDgCuqqqqqogOAODu7u7u7gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-0\"\n    },\n    \"image3\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADu7u7u7g4A4Myqqqqq6gDgrKqqqqqqDuCs7qqq7ooO4Kzuqqruig7grKqqqqqKDuCsqqqqqugAAO7u7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-2\"\n    },\n    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADu7u7u7g4A4Myqqqqq6gDgrKqqqqqqDuCs7qqq7ooO4Kzuqqruig7grKqqqqqKDuCsqqqqqugAAO7u7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-180\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}"},{"type":"added","filename":"images.g.ts","value":"// Auto-generated code. Do not edit.\nnamespace myImages {\n\n    helpers._registerFactory(\"image\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"image1\":\n            case \"boat-0\":return img`\n. . . . . . . . . . . . . . . . \n. . . . . . e e e e . . . . . . \n. . . . . e c c c a e . . . . . \n. . . . e c a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a 8 e . . . . \n. . . . e 8 8 8 8 8 8 e . . . . \n. . . . . e e e e e e . . . . . \n. . . . . . . . . . . . . . . . \n`;\n            case \"image3\":\n            case \"boat-2\":return img`\n. . . . . . . . . . . . . . . . \n. . . . . e e e e e e . . . . . \n. . . . e c c c c c c e . . . . \n. . . . e c a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a 8 e . . . . \n. . . . . e a 8 8 8 e . . . . . \n. . . . . . e e e e . . . . . . \n. . . . . . . . . . . . . . . . \n`;\n            case \"image2\":\n            case \"boat-180\":return img`\n. . . . . . . . . . . . . . . . \n. . . . . e e e e e e . . . . . \n. . . . e c c c c c c e . . . . \n. . . . e c a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a 8 e . . . . \n. . . . . e a 8 8 8 e . . . . . \n. . . . . . e e e e . . . . . . \n. . . . . . . . . . . . . . . . \n`;\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"animation\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"song\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n"}]},{"timestamp":1759523738758,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"images.g.jres","patch":[{"start1":2,"length1":300,"diffs":[[1,""]]},{"start1":18,"length1":204,"diffs":[[1,"        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7u4AAM6qqqqqig7grKqqqqqKDuCs7qqq7ooO4Kzuqqruig7gqqqqqqqKDgCuqqqqqogOAODu7u7u7gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n"]]},{"start1":316,"length1":204,"diffs":[[1,"        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADu7u7u7g4A4Myqqqqq6gDgrKqqqqqqDuCs7qqq7ooO4Kzuqqruig7grKqqqqqKDuCsqqqqqugAAO7u7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n"]]},{"start1":598,"length1":0,"diffs":[[1,"    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADu7u7u7g4A4Myqqqqq6gDgrKqqqqqqDuCs7qqq7ooO4Kzuqqruig7grKqqqqqKDuCsqqqqqugAAO7u7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-180\"\n    },\n"]]}]},{"type":"edited","filename":"images.g.ts","patch":[{"start1":165,"length1":67,"diffs":[[1,"            case \"image1\":\n            case \"boat-0\":return img`\n"]]},{"start1":263,"length1":33,"diffs":[[1,". . . . . . e e e e . . . . . . \n. . . . . e c c c a e . . . . . \n. . . . e c a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n"]]},{"start1":494,"length1":0,"diffs":[[1,". . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n"]]},{"start1":626,"length1":0,"diffs":[[1,". . . . e a a a a a 8 e . . . . \n. . . . e 8 8 8 8 8 8 e . . . . \n. . . . . e e e e e e . . . . . \n. . . . . . . . . . . . . . . . \n`;\n            case \"image3\":\n            case \"boat-2\":return img`\n. . . . . . . . . . . . . . . . \n. . . . . e e e e e e . . . . . \n. . . . e c c c c c c e . . . . \n. . . . e c a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n"]]},{"start1":1222,"length1":66,"diffs":[[1,". . . . e a a a a a 8 e . . . . \n. . . . . e a 8 8 8 e . . . . . \n"]]},{"start1":1357,"length1":65,"diffs":[[1,"            case \"image2\":\n            case \"boat-180\":return img`\n"]]},{"start1":1457,"length1":99,"diffs":[[1,". . . . . e e e e e e . . . . . \n. . . . e c c c c c c e . . . . \n. . . . e c a a a a a e . . . . \n"]]},{"start1":1820,"length1":99,"diffs":[[1,". . . . e a a a a a 8 e . . . . \n. . . . . e a 8 8 8 e . . . . . \n. . . . . . e e e e . . . . . . \n"]]},{"start1":1955,"length1":596,"diffs":[[1,""]]}]}]},{"timestamp":1759524289774,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"images.g.jres","patch":[{"start1":2,"length1":220,"diffs":[[1,"    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADu7u7u7g4A4Kqqqqqq6gDgqqqqqqqqDuCq7qqq7qoO4Kruqqruqg7gqqqqqqqqDuCqqqqqquoAAO7u7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n"]]},{"start1":261,"length1":33,"diffs":[[1,"        \"displayName\": \"boat-180\"\n"]]},{"start1":302,"length1":300,"diffs":[[1,""]]},{"start1":318,"length1":204,"diffs":[[1,"        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7u4AAK6qqqqqqg7gqqqqqqqqDuCq7qqq7qoO4Kruqqruqg7gqqqqqqqqDgCuqqqqqqoOAODu7u7u7gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n"]]},{"start1":600,"length1":220,"diffs":[[1,"    \"image3\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAADu7gAAAAAA4KrODgAAAADgquoMAAAAAOCq6gwAAAAA4KrqDAAAAADg6uoMAAAAAODq6gwAAAAA4OrqDAAAAADgquoMAAAAAOCq6gwAAAAAAK7ODAAAAAAArs4OAAAAAACu7gAAAAAAAOAAAAAAAAAAAAAAAA==\",\n"]]},{"start1":859,"length1":34,"diffs":[[1,"        \"displayName\": \"boat-2\"\n"]]},{"start1":898,"length1":299,"diffs":[[1,""]]}]},{"type":"edited","filename":"images.g.ts","patch":[{"start1":165,"length1":66,"diffs":[[1,"            case \"image2\":\n            case \"boat-180\":return img`\n"]]},{"start1":265,"length1":1260,"diffs":[[1,". . . . . e e e e e e . . . . . \n"]]},{"start1":364,"length1":66,"diffs":[[1,""]]},{"start1":562,"length1":33,"diffs":[[1,". . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . . e a a a a e . . . . . \n. . . . . . e e e e . . . . . . \n"]]},{"start1":760,"length1":33,"diffs":[[1,""]]},{"start1":763,"length1":67,"diffs":[[1,"            case \"image1\":\n            case \"boat-0\":return img`\n"]]},{"start1":861,"length1":66,"diffs":[[1,". . . . . . e e e e . . . . . . \n. . . . . e a a a a e . . . . . \n"]]},{"start1":960,"length1":0,"diffs":[[1,". . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n"]]},{"start1":1125,"length1":0,"diffs":[[1,". . . . e a a a a a a e . . . . \n"]]},{"start1":1290,"length1":132,"diffs":[[1,". . . . . e e e e e e . . . . . \n"]]},{"start1":1359,"length1":66,"diffs":[[1,"            case \"image3\":\n            case \"boat-2\":return img`\n"]]},{"start1":1490,"length1":429,"diffs":[[1,""]]},{"start1":1523,"length1":0,"diffs":[[1,". . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . e e e e e e e e e . . . . . \n. e a a a a a a a a a e e e . . \n. e a a a a e e e a a a a a e . \n. e e a a a a a a a a e e e . . \n. e c e e e e e e e e c c e . . \n. . e c c c c c c c c c e . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n"]]}]}]},{"timestamp":1759524749421,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"images.g.jres","patch":[{"start1":601,"length1":0,"diffs":[[1,"    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gDgqqqqqqrqAOCqquququoA4Kqq6q6q6gDgqqqqqqrqAACuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-0\"\n    },\n"]]},{"start1":1498,"length1":1746,"diffs":[[1,""]]}]},{"type":"edited","filename":"images.g.ts","patch":[{"start1":1360,"length1":0,"diffs":[[1,"            case \"image1\":\n            case \"boat-0\":return img`\n. . . . . . . . . . . . . . . . \n. . . . . . e e e e . . . . . . \n. . . . . e a a a a e . . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . . e e e e e e . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n`;\n"]]},{"start1":3151,"length1":2390,"diffs":[[1,""]]},{"start1":3300,"length1":597,"diffs":[[1,"\n"]]}]}]},{"timestamp":1759525230740,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"images.g.jres","patch":[{"start1":2523,"length1":1748,"diffs":[[1,"        \"data\": \"YzgwMDEwMDAxMDAwMDEwMDAwMDAwMDYwNjYwMDAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjY2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA=\",\n"]]}]},{"type":"edited","filename":"images.g.ts","patch":[{"start1":5687,"length1":2144,"diffs":[[1,""]]}]}]},{"timestamp":1759526145294,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":3243,"length1":5,"diffs":[[1,""]]}]}]},{"timestamp":1759526200610,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":2878,"length1":47,"diffs":[[1,""]]},{"start1":3243,"length1":1,"diffs":[[1,"    \n"]]}]},{"type":"edited","filename":"images.g.jres","patch":[{"start1":601,"length1":0,"diffs":[[1,"    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gAArqqqqqqqDgCuququqqoOAK6q6q6qqg4ArqqqqqqqDgCuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-180\"\n    },\n"]]},{"start1":2359,"length1":31,"diffs":[[1,"        \"displayName\": \"boat-0\"\n"]]},{"start1":2398,"length1":299,"diffs":[[1,""]]}]},{"type":"edited","filename":"images.g.ts","patch":[{"start1":1360,"length1":0,"diffs":[[1,"            case \"image2\":\n            case \"boat-180\":return img`\n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . e e e e e e . . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a e e a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . e a a a a a a e . . . . \n. . . . . e a a a a e . . . . . \n. . . . . . e e e e . . . . . . \n. . . . . . . . . . . . . . . . \n`;\n"]]},{"start1":4376,"length1":37,"diffs":[[1,"            case \"boat-0\":return img`\n"]]},{"start1":4945,"length1":597,"diffs":[[1,""]]}]}]},{"timestamp":1759541814002,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":2878,"length1":50,"diffs":[[1,"let boat = sprites.create(assets.image`boat0`)\n"]]}]}]},{"timestamp":1759589939358,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"images.g.jres","patch":[{"start1":2113,"length1":204,"diffs":[[1,"        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gAArqqqqqqqDgCuququqqoOAK6q6q6qqg4ArqqqqqqqDgCuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n"]]}]}]},{"timestamp":1759589947111,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":2878,"length1":0,"diffs":[[1,"// let boat = sprites.create(assets.image`boat0`)\n"]]},{"start1":2929,"length1":103,"diffs":[[1,""]]}]},{"type":"edited","filename":"images.g.jres","patch":[{"start1":2,"length1":0,"diffs":[[1,"    \"image3\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAODuDgAAAAAArursAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACurs4AAAAAAK6uzgAAAAAArq7OAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAOCq7gAAAAAAAO4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-90\"\n    },\n"]]},{"start1":1800,"length1":220,"diffs":[[1,"    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gDgqqqqqqrqAOCqquququoA4Kqq6q6q6gDgqqqqqqrqAACuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n"]]},{"start1":2059,"length1":33,"diffs":[[1,"        \"displayName\": \"boat0\"\n"]]},{"start1":2356,"length1":34,"diffs":[[1,"        \"displayName\": \"boat180\"\n"]]},{"start1":2396,"length1":298,"diffs":[[1,""]]}]},{"type":"edited","filename":"images.g.ts","patch":[{"start1":165,"length1":0,"diffs":[[1,"            case \"image3\":\n            case \"boat-90\":return img`\n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . e e e e e e e e e e e . . . \n. e a a a a a a a a a a a e . . \n. e a a a a e e e a a a a a e . \n. e e a a a a a a a a a a a e . \n. e c e e e e e e e e e e e e . \n. . e c c c c c c c c c c e . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n`;\n"]]},{"start1":3751,"length1":66,"diffs":[[1,"            case \"image1\":\n            case \"boat0\":return img`\n"]]},{"start1":3848,"length1":664,"diffs":[[1,". . . . . . e e e e . . . . . . \n. . . . . e a a a a e . . . . . \n"]]},{"start1":4244,"length1":66,"diffs":[[1,". . . . . e e e e e e . . . . . \n"]]},{"start1":4310,"length1":0,"diffs":[[1,". . . . . . . . . . . . . . . . \n"]]},{"start1":4346,"length1":65,"diffs":[[1,"            case \"image2\":\n            case \"boat180\":return img`\n"]]},{"start1":4445,"length1":66,"diffs":[[1,". . . . . . . . . . . . . . . . \n. . . . . e e e e e e . . . . . \n"]]},{"start1":4841,"length1":66,"diffs":[[1,". . . . . e a a a a e . . . . . \n. . . . . . e e e e . . . . . . \n"]]}]}]},{"timestamp":1759591927519,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"water_sim.ts","patch":[{"start1":3819,"length1":147,"diffs":[[1,"Shaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})"]]}]}]},{"timestamp":1759591977214,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":7916,"length1":51,"diffs":[[1,"        for (let i = 0; i < ripples.length && i < 4; i++) {\n"]]},{"start1":8300,"length1":64,"diffs":[[1,"    //     runShader(checkerWithRipple, screen, uniforms);\n"]]}]},{"type":"edited","filename":"water_sim.ts","patch":[{"start1":2879,"length1":0,"diffs":[[1,"let boat = assets.image`boat_0`\nconsole.log(boat)\n\n"]]},{"start1":3505,"length1":50,"diffs":[[1,"    let uvy = frag.y / u.resolution.y + h * 0.15;\n"]]},{"start1":3819,"length1":135,"diffs":[[1,"// Shaders.initDefaults()\n// Shaders.setActiveProgram((uniforms, screen) => {\n//     Shaders.runShader(checkerWaterShader, screen, uniforms);\n// })"]]}]}]},{"timestamp":1759592521743,"editorVersion":"2.0.59","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace Shaders {\" line1=\"    const exampleShader: Shader = (frag, u) =&gt; {\" line2=\"        const x = frag.x / u.resolution.x;\" line3=\"        const y = frag.y / u.resolution.y;\" line4=\"\" line5=\"        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\" line6=\"        return v &gt; 0 ? 0.2 : 0.8;\" line7=\"    };\" line8=\"\" line9=\"    const plasmaShader: Shaders.Shader = (frag, u) =&gt; {\" line10=\"        // normalize coordinates\" line11=\"        const nx = frag.x / u.resolution.x;\" line12=\"        const ny = frag.y / u.resolution.y;\" line13=\"\" line14=\"        // combine multiple sine waves\" line15=\"        const w =\" line16=\"            Math.sin(nx * 10 + u.time) +\" line17=\"            Math.sin((ny * 10) + u.time * 1.3) +\" line18=\"            Math.sin((nx + ny) * 10 + u.time * 0.7);\" line19=\"\" line20=\"        // normalize to 0..1\" line21=\"        const normalized = (w + 3) / 6;\" line22=\"\" line23=\"        // map to grayscale shade (1–15)\" line24=\"        return normalized;\" line25=\"    };\" line26=\"\" line27=\"    const rippleShader: Shaders.Shader = (frag, u) =&gt; {\" line28=\"        const cx = frag.x - u.resolution.x / 2;\" line29=\"        const cy = frag.y - u.resolution.y / 2;\" line30=\"        const dist = Math.sqrt(cx * cx + cy * cy);\" line31=\"\" line32=\"        const a = Math.sin(dist * 0.1 - u.time * 2);\" line33=\"        const normalized2 = (a + 1) / 2;\" line34=\"\" line35=\"        return normalized2;\" line36=\"    };\" line37=\"\" line38=\"    const tunnelShader: Shaders.Shader = (frag, u) =&gt; {\" line39=\"        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\" line40=\"        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\" line41=\"\" line42=\"        const angle = Math.atan2(ny2, nx2);\" line43=\"        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\" line44=\"\" line45=\"        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\" line46=\"        return (b + 1) / 2;\" line47=\"    };\" line48=\"\" line49=\"    const checkerShader: Shaders.Shader = (frag, u) =&gt; {\" line50=\"        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\" line51=\"\" line52=\"        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\" line53=\"        return c ? 1.0 : 0.0;\" line54=\"    };\" line55=\"\" line56=\"    const circlesShader: Shaders.Shader = (frag, u) =&gt; {\" line57=\"        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\" line58=\"        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\" line59=\"\" line60=\"        const dx = frag.x - cx2;\" line61=\"        const dy = frag.y - cy2;\" line62=\"        const dist3 = Math.sqrt(dx * dx + dy * dy);\" line63=\"\" line64=\"        const d = Math.sin(dist3 * 0.2 - u.time * 2);\" line65=\"        return (d + 1) / 2;\" line66=\"    };\" line67=\"\" line68=\"    const marbleShader: Shaders.Shader = (frag, u) =&gt; {\" line69=\"        const nx3 = frag.x / u.resolution.x;\" line70=\"        const ny3 = frag.y / u.resolution.y;\" line71=\"\" line72=\"        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\" line73=\"        return (e + 1) / 2;\" line74=\"    };\" line75=\"\" line76=\"    const marbleWithWobble: Shaders.Shader = (frag, u) =&gt; {\" line77=\"        // normalized UVs 0..1\" line78=\"        let uvx = frag.x / u.resolution.x;\" line79=\"        let uvy = frag.y / u.resolution.y;\" line80=\"\" line81=\"        // warp Y coordinate\" line82=\"        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\" line83=\"\" line84=\"        // base marble pattern\" line85=\"        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\" line86=\"\" line87=\"        // GLSL does (v + 1)/2 to map -1..1 → 0..1\" line88=\"        return (f + 1.0) * 0.5;\" line89=\"    };\" line90=\"\" line91=\"    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\" line92=\"        // center coords\" line93=\"        const cx3 = frag.x - u.resolution.x / 2;\" line94=\"        const cy3 = frag.y - u.resolution.y / 2;\" line95=\"        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\" line96=\"\" line97=\"        // ripple parameters\" line98=\"        const freq = 0.1;     // wave spacing\" line99=\"        const speed = 4.0;    // animation speed\" line100=\"        const baseAmp = 0.05; // base amplitude\" line101=\"\" line102=\"        // damping: amplitude decays with distance\" line103=\"        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\" line104=\"\" line105=\"        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\" line106=\"\" line107=\"        // normalized UVs\" line108=\"        const uvx2 = frag.x / u.resolution.x;\" line109=\"        let uvy2 = frag.y / u.resolution.y;\" line110=\"\" line111=\"        // apply vertical ripple distortion\" line112=\"        uvy2 += offset;\" line113=\"\" line114=\"        return new Shaders.Vec2(uvx2, uvy2);\" line115=\"    }\" line116=\"\" line117=\"    const marbleWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line118=\"        // ripple-distorted UVs\" line119=\"        const uv = rippleWarp(frag, u);\" line120=\"\" line121=\"        // marble pattern\" line122=\"        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\" line123=\"\" line124=\"        // normalize to 0..1\" line125=\"        return (g + 1.0) * 0.5;\" line126=\"    };\" line127=\"\" line128=\"    // Checkerboard + radial ripple (UV warp) + brightness shimmer\" line129=\"    // Phases for warp and shimmer are split so you can tune alignment.\" line130=\"\" line131=\"    const checkerWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line132=\"        // --- 1. Distance from screen center ---\" line133=\"        const dx2 = frag.x - u.resolution.x / 2;\" line134=\"        const dy2 = frag.y - u.resolution.y / 2;\" line135=\"        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\" line136=\"\" line137=\"        // --- 2. Base ripple parameters ---\" line138=\"        const freq2 = 0.12;                   // ripple spacing\" line139=\"        const speed2 = 3.0;                   // animation speed\" line140=\"        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\" line141=\"        const phase = dist5 * freq2 - u.time * speed2;\" line142=\"\" line143=\"        // --- 3. Warp the UVs (position ripple) ---\" line144=\"        const uvx3 = frag.x / u.resolution.x;\" line145=\"        let uvy3 = frag.y / u.resolution.y;\" line146=\"\" line147=\"        const warpAmp = 0.05;\" line148=\"        const wave = Math.sin(phase);\" line149=\"        uvy3 += wave * warpAmp * damping2;\" line150=\"\" line151=\"        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\" line152=\"        const tiles = 10;\" line153=\"        const tx = Math.floor(uvx3 * tiles);\" line154=\"        const ty = Math.floor(uvy3 * tiles);\" line155=\"        const isWhite = ((tx + ty) &amp; 1) ? 1 : 0;\" line156=\"\" line157=\"        const baseBlack = 0.1;\" line158=\"        const baseWhite = 0.9;\" line159=\"        const base = isWhite ? baseWhite : baseBlack;\" line160=\"\" line161=\"        // --- 5. Recalculate radial distance *after* warp ---\" line162=\"        const dx22 = frag.x - u.resolution.x / 2;\" line163=\"        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\" line164=\"        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\" line165=\"\" line166=\"        // --- 6. Shimmer based on warped radial distance ---\" line167=\"        const shimmerPhase = distWarped * freq2 - u.time * speed2;\" line168=\"        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\" line169=\"\" line170=\"        // --- 7. Combine and clamp ---\" line171=\"        let L = base + shimmer;\" line172=\"        if (L &lt; 0) L = 0;\" line173=\"        if (L &gt; 1) L = 1;\" line174=\"\" line175=\"        return L;\" line176=\"    };\" line177=\"\" line178=\"    interface Ripple {\" line179=\"        origin: Shaders.Vec2;\" line180=\"        startTime: number;\" line181=\"\" line182=\"        // precomputed each frame\" line183=\"        age?: number;\" line184=\"        waveDist?: number;\" line185=\"    }\" line186=\"\" line187=\"    let ripples: Ripple[] = [];\" line188=\"\" line189=\"    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\" line190=\"        ripples.push({\" line191=\"            origin: new Shaders.Vec2(x, y),\" line192=\"            startTime: game.runtime() / 1000\" line193=\"        });\" line194=\"    })\" line195=\"\" line196=\"    game.onUpdate(() =&gt; {\" line197=\"        const now = game.runtime() / 1000;\" line198=\"        ripples = ripples.filter(r =&gt; now - r.startTime &lt; 5); // keep last 5s\" line199=\"\" line200=\"        // precompute per-ripple values once per frame\" line201=\"        for (const r of ripples) {\" line202=\"            r.age = now - r.startTime;\" line203=\"            r.waveDist = r.age * 40; // speed in px/sec\" line204=\"        }\" line205=\"    });\" line206=\"\" line207=\"    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\" line208=\"        const dx3 = frag.x - r.origin.x;\" line209=\"        const dy3 = frag.y - r.origin.y;\" line210=\"        const dist22 = dx3 * dx3 + dy3 * dy3;\" line211=\"\" line212=\"        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\" line213=\"        const diff = dist6 - (r.waveDist || 0);\" line214=\"\" line215=\"        // cull if pixel is far from wavefront\" line216=\"        if (Math.abs(diff) &gt; 40) return 0;\" line217=\"\" line218=\"        // simple triangular falloff instead of exp()\" line219=\"        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\" line220=\"\" line221=\"        // cheap oscillation (precompute freq/speed if needed)\" line222=\"        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\" line223=\"    }\" line224=\"\" line225=\"    const checkerWithRippleClick: Shaders.Shader = (frag, u) =&gt; {\" line226=\"        // --- Checkerboard base ---\" line227=\"        const uvx4 = frag.x / u.resolution.x;\" line228=\"        const uvy4 = frag.y / u.resolution.y;\" line229=\"        const scale2 = 10;\" line230=\"        const tx2 = Math.floor(uvx4 * scale2);\" line231=\"        const ty2 = Math.floor(uvy4 * scale2);\" line232=\"        const isWhite2 = ((tx2 + ty2) &amp; 1) ? 1 : 0;\" line233=\"        const base2 = isWhite2 ? 0.9 : 0.1;\" line234=\"\" line235=\"        // --- Accumulate ripple contributions ---\" line236=\"        let rippleSum = 0;\" line237=\"        for (let i = 0; i &lt; ripples.length &amp;&amp; i &lt; 4; i++) {\" line238=\"            rippleSum += rippleContribution(frag, ripples[i]);\" line239=\"        }\" line240=\"\" line241=\"        // combine (tune ripple strength)\" line242=\"        let L2 = base2 + rippleSum;\" line243=\"\" line244=\"        // clamp\" line245=\"        if (L2 &lt; 0) L2 = 0;\" line246=\"        if (L2 &gt; 1) L2 = 1;\" line247=\"\" line248=\"        return L2;\" line249=\"    };\" line250=\"\" line251=\"    // initDefaults()\" line252=\"    // setActiveProgram((uniforms, screen) =&gt; {\" line253=\"    //     runShader(checkerWithRipple, screen, uniforms);\" line254=\"    // })\" line255=\"}\" numlines=\"256\"></mutation></block></statement></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":353,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"water_sim.ts","patch":[{"start1":2931,"length1":233,"diffs":[[1,"browserEvents.onMouseMove(function(x: number, y: number) {\n    mouse.x = x\n    mouse.y = y\n    if (browserEvents.MouseLeft.isPressed()) {\n        WaterSim.splash(rippleOrigin.x, rippleOrigin.y, 1.0, 4);\n    }\n})\n"]]},{"start1":3144,"length1":163,"diffs":[[1,"game.onUpdate(function () {\n    WaterSim.step();\n    const move = mouse.sub(rippleOrigin).normalize().mul(5)\n    rippleOrigin = rippleOrigin.add(move)\n"]]},{"start1":3296,"length1":7,"diffs":[[1,"});\n"]]},{"start1":3768,"length1":147,"diffs":[[1,"Shaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1759349373593,"editorVersion":"2.0.58","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1759357797298,"editorVersion":"2.0.58","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"","README.md":" ","assets.json":"","types.ts":"\nnamespace Shaders {\n    export interface Uniforms {\n        resolution: [number, number];\n        time: number;\n        frame: number;\n        mouse?: [number, number];\n    }\n\n    export type Shader = (\n        fragCoord: [number, number],\n        uniforms: Uniforms\n    ) => number;\n\n    export class Vec2 {\n        constructor(public x: number, public y: number) { }\n\n        static fromTuple(tuple: [number, number]) {\n            const [x, y] = tuple\n            return new Vec2(x, y);\n        }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n\n        toTuple(): [number, number] { return [this.x, this.y]; }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n\n    function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        const [w, h] = uniforms.resolution;\n\n        for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n                const color = shader([x, y], uniforms);\n                img.setPixel(x, y, color);\n            }\n        }\n    }\n\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag[0] / u.resolution[0];\n        const y = frag[1] / u.resolution[1];\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 7 : 2; // pick palette colors\n    };\n\n\n    let frame = 0;\n    game.onUpdate(function () {\n        const uniforms: Uniforms = {\n            resolution: [screen.width, screen.height],\n            time: game.runtime() / 1000, // seconds\n            frame: frame++\n        };\n\n        runShader(exampleShader, screen, uniforms);\n    });\n}","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1759441968261,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n\n    function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const color = shader(new Vec2(x, y), uniforms);\n                img.setPixel(x, y, color);\n            }\n        }\n    }\n\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? game.Color.Yellow : game.Color.Blue;\n    };\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    game.onUpdate(function () {\n        const uniforms: Uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        runShader(exampleShader, screen, uniforms);\n\n        scene.setBackgroundImage(screen)\n    });\n}","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1759505289563,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const color = shader(new Vec2(x, y), uniforms);\n                img.setPixel(x, y, color);\n            }\n        }\n    }\n\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? game.Color.Yellow : game.Color.Blue;\n    };\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    \n    game.onUpdate(function () {\n        const uniforms: Uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        runShader(exampleShader, screen, uniforms);\n\n        scene.setBackgroundImage(screen)\n    });\n}","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759507313404,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"10\" y=\"10\"></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? Color.fromFloat(0.2) : Color.fromFloat(0.8);\n    };\n\n    game.onUpdate(() => {\n        runShader(exampleShader, screen, getUniforms());\n        scene.setBackgroundImage(screen)\n    })\n}","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => Color;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const color = shader(new Vec2(x, y), uniforms);\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    export function getUniforms(): Uniforms {\n        return uniforms\n    }\n    \n    game.onUpdate(function () {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        scene.setBackgroundImage(screen)\n    });\n\n    export function attachLoop(): void {\n        \n    }\n}","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759509137511,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"10\" y=\"10\"></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const v =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (v + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const v = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized = (v + 1) / 2;\n\n        return normalized;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny, nx);\n        const dist = Math.sqrt(nx * nx + ny * ny);\n\n        const v = Math.sin(10 * dist - u.time * 3 + angle * 5);\n        return (v + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const v = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return v ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx;\n        const dy = frag.y - cy;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        const v = Math.sin(dist * 0.2 - u.time * 2);\n        return (v + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        const v = Math.sin(nx * 10 + Math.sin(ny * 10 + u.time));\n        return (v + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const v = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (v + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist * 0.01); // tweak factor\n\n        const offset = Math.sin(dist * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy += offset;\n\n        return new Shaders.Vec2(uvx, uvy);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const v = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (v + 1.0) * 0.5;\n    };\n\n    initDefaults()\n    setActiveProgram((uniforms, screen) => {\n        runShader(marbleWithRipple, screen, uniforms);\n    })\n}","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759510943192,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"10\" y=\"10\"></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const v =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (v + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const v = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized = (v + 1) / 2;\n\n        return normalized;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny, nx);\n        const dist = Math.sqrt(nx * nx + ny * ny);\n\n        const v = Math.sin(10 * dist - u.time * 3 + angle * 5);\n        return (v + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const v = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return v ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx;\n        const dy = frag.y - cy;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        const v = Math.sin(dist * 0.2 - u.time * 2);\n        return (v + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        const v = Math.sin(nx * 10 + Math.sin(ny * 10 + u.time));\n        return (v + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const v = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (v + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist * 0.01); // tweak factor\n\n        const offset = Math.sin(dist * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy += offset;\n\n        return new Shaders.Vec2(uvx, uvy);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const v = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (v + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- ripple math (radial distance) ---\n        const dx = frag.x - u.resolution.x / 2;\n        const dy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        const freq = 0.12;                   // ripple spacing\n        const speed = 3.0;                   // animation speed\n        const damping = 1.0 / (1.0 + dist * 0.06);\n        const phase = dist * freq - u.time * speed;\n\n        // --- UV distortion (position ripple) ---\n        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy += wave * warpAmp * damping;\n\n        // --- checkerboard on warped UVs ---\n        const tiles = 10;\n        const tx = Math.floor(uvx * tiles);\n        const ty = Math.floor(uvy * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- brightness ripple (light follows warped Y) ---\n        // use uvy (warped coord) so brightness crest aligns with checker movement\n        const shimmerPhase = (uvy * u.resolution.y) * freq - u.time * speed;\n        const shimmer = Math.sin(shimmerPhase) * 0.25 * damping;\n\n        // --- final luminance ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    initDefaults()\n    setActiveProgram((uniforms, screen) => {\n        runShader(checkerWithRipple, screen, uniforms);\n    })\n}","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759512746373,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"10\" y=\"10\"></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const v =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (v + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const v = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized = (v + 1) / 2;\n\n        return normalized;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny, nx);\n        const dist = Math.sqrt(nx * nx + ny * ny);\n\n        const v = Math.sin(10 * dist - u.time * 3 + angle * 5);\n        return (v + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const v = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return v ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx;\n        const dy = frag.y - cy;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        const v = Math.sin(dist * 0.2 - u.time * 2);\n        return (v + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        const v = Math.sin(nx * 10 + Math.sin(ny * 10 + u.time));\n        return (v + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const v = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (v + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist * 0.01); // tweak factor\n\n        const offset = Math.sin(dist * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy += offset;\n\n        return new Shaders.Vec2(uvx, uvy);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const v = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (v + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- 1. Distance from screen center ---\n        const dx = frag.x - u.resolution.x / 2;\n        const dy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        // --- 2. Base ripple parameters ---\n        const freq = 0.12;                   // ripple spacing\n        const speed = 3.0;                   // animation speed\n        const damping = 1.0 / (1.0 + dist * 0.06);\n        const phase = dist * freq - u.time * speed;\n\n        // --- 3. Warp the UVs (position ripple) ---\n        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy += wave * warpAmp * damping;\n\n        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\n        const tiles = 10;\n        const tx = Math.floor(uvx * tiles);\n        const ty = Math.floor(uvy * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- 5. Recalculate radial distance *after* warp ---\n        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = (uvy * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        // --- 6. Shimmer based on warped radial distance ---\n        const shimmerPhase = distWarped * freq - u.time * speed;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping;\n\n        // --- 7. Combine and clamp ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    interface Ripple {\n        origin: Shaders.Vec2;\n        startTime: number;\n\n        // precomputed each frame\n        age?: number;\n        waveDist?: number;\n    }\n\n    let ripples: Ripple[] = [];\n\n    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n        ripples.push({\n            origin: new Shaders.Vec2(x, y),\n            startTime: game.runtime() / 1000\n        });\n    })\n\n    game.onUpdate(() => {\n        const now = game.runtime() / 1000;\n        ripples = ripples.filter(r => now - r.startTime < 5); // keep last 5s\n\n        // precompute per-ripple values once per frame\n        for (const r of ripples) {\n            r.age = now - r.startTime;\n            r.waveDist = r.age * 40; // speed in px/sec\n        }\n    });\n\n    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\n        const dx = frag.x - r.origin.x;\n        const dy = frag.y - r.origin.y;\n        const dist2 = dx * dx + dy * dy;\n\n        const dist = Math.sqrt(dist2); // one sqrt only if near the ripple\n        const diff = dist - (r.waveDist || 0);\n\n        // cull if pixel is far from wavefront\n        if (Math.abs(diff) > 40) return 0;\n\n        // simple triangular falloff instead of exp()\n        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\n\n        // cheap oscillation (precompute freq/speed if needed)\n        return Math.sin(dist * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n    }\n\n    const checkerWithRippleClick: Shaders.Shader = (frag, u) => {\n        // --- Checkerboard base ---\n        const uvx = frag.x / u.resolution.x;\n        const uvy = frag.y / u.resolution.y;\n        const scale = 10;\n        const tx = Math.floor(uvx * scale);\n        const ty = Math.floor(uvy * scale);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n        const base = isWhite ? 0.9 : 0.1;\n\n        // --- Accumulate ripple contributions ---\n        let rippleSum = 0;\n        for (let i = 0; i < ripples.length && i < 4; i++) {\n            rippleSum += rippleContribution(frag, ripples[i]);\n        }\n\n        // combine (tune ripple strength)\n        let L = base + rippleSum;\n\n        // clamp\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    initDefaults()\n    setActiveProgram((uniforms, screen) => {\n        runShader(checkerWithRippleClick, screen, uniforms);\n    })\n}","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759521878914,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"10\" y=\"10\"></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const v =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (v + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const v = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized = (v + 1) / 2;\n\n        return normalized;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny, nx);\n        const dist = Math.sqrt(nx * nx + ny * ny);\n\n        const v = Math.sin(10 * dist - u.time * 3 + angle * 5);\n        return (v + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const v = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return v ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx;\n        const dy = frag.y - cy;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        const v = Math.sin(dist * 0.2 - u.time * 2);\n        return (v + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        const v = Math.sin(nx * 10 + Math.sin(ny * 10 + u.time));\n        return (v + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const v = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (v + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist * 0.01); // tweak factor\n\n        const offset = Math.sin(dist * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy += offset;\n\n        return new Shaders.Vec2(uvx, uvy);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const v = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (v + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- 1. Distance from screen center ---\n        const dx = frag.x - u.resolution.x / 2;\n        const dy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n\n        // --- 2. Base ripple parameters ---\n        const freq = 0.12;                   // ripple spacing\n        const speed = 3.0;                   // animation speed\n        const damping = 1.0 / (1.0 + dist * 0.06);\n        const phase = dist * freq - u.time * speed;\n\n        // --- 3. Warp the UVs (position ripple) ---\n        const uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy += wave * warpAmp * damping;\n\n        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\n        const tiles = 10;\n        const tx = Math.floor(uvx * tiles);\n        const ty = Math.floor(uvy * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- 5. Recalculate radial distance *after* warp ---\n        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = (uvy * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        // --- 6. Shimmer based on warped radial distance ---\n        const shimmerPhase = distWarped * freq - u.time * speed;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping;\n\n        // --- 7. Combine and clamp ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    interface Ripple {\n        origin: Shaders.Vec2;\n        startTime: number;\n\n        // precomputed each frame\n        age?: number;\n        waveDist?: number;\n    }\n\n    let ripples: Ripple[] = [];\n\n    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n        ripples.push({\n            origin: new Shaders.Vec2(x, y),\n            startTime: game.runtime() / 1000\n        });\n    })\n\n    game.onUpdate(() => {\n        const now = game.runtime() / 1000;\n        ripples = ripples.filter(r => now - r.startTime < 5); // keep last 5s\n\n        // precompute per-ripple values once per frame\n        for (const r of ripples) {\n            r.age = now - r.startTime;\n            r.waveDist = r.age * 40; // speed in px/sec\n        }\n    });\n\n    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\n        const dx = frag.x - r.origin.x;\n        const dy = frag.y - r.origin.y;\n        const dist2 = dx * dx + dy * dy;\n\n        const dist = Math.sqrt(dist2); // one sqrt only if near the ripple\n        const diff = dist - (r.waveDist || 0);\n\n        // cull if pixel is far from wavefront\n        if (Math.abs(diff) > 40) return 0;\n\n        // simple triangular falloff instead of exp()\n        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\n\n        // cheap oscillation (precompute freq/speed if needed)\n        return Math.sin(dist * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n    }\n\n    const checkerWithRippleClick: Shaders.Shader = (frag, u) => {\n        // --- Checkerboard base ---\n        const uvx = frag.x / u.resolution.x;\n        const uvy = frag.y / u.resolution.y;\n        const scale = 10;\n        const tx = Math.floor(uvx * scale);\n        const ty = Math.floor(uvy * scale);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n        const base = isWhite ? 0.9 : 0.1;\n\n        // --- Accumulate ripple contributions ---\n        let rippleSum = 0;\n        for (let i = 0; i < ripples.length && i < 4; i++) {\n            rippleSum += rippleContribution(frag, ripples[i]);\n        }\n\n        // combine (tune ripple strength)\n        let L = base + rippleSum;\n\n        // clamp\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    // initDefaults()\n    // setActiveProgram((uniforms, screen) => {\n    //     runShader(checkerWithRipple, screen, uniforms);\n    // })\n}","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","water_sim.ts":"namespace WaterSim {\n    export const GW = 60;\n    export const GH = 45;\n    const FP = 256;\n\n    // Damping\n    const DAMP_NUM = 230;\n    const DAMP_SHIFT = 8;\n\n    // Pre-allocate buffers as plain number[] with fixed size\n    const SIZE = GW * GH;\n    let A: number[] = [];\n    let B: number[] = [];\n    let C: number[] = [];\n\n    // Manual initialization (no `new Array`)\n    export function init() {\n        A = [];\n        B = [];\n        C = [];\n        for (let i = 0; i < SIZE; i++) {\n            A.push(0);\n            B.push(0);\n            C.push(0);\n        }\n    }\n\n    let prev: number[];\n    let cur: number[];\n    let nextB: number[];\n\n    export function reset() {\n        init();\n        prev = A;\n        cur = B;\n        nextB = C;\n    }\n\n    function idx(x: number, y: number) { return y * GW + x; }\n\n    // Splash at screen coords\n    export function splash(sx: number, sy: number, strength = 1, radiusPx = 10) {\n        const gx = Math.idiv(sx * GW, screen.width);\n        const gy = Math.idiv(sy * GH, screen.height);\n        const r = Math.max(1, Math.idiv(radiusPx * GW, screen.width));\n\n        const amp = (strength * FP) | 0;\n\n        for (let y = Math.max(1, gy - r); y <= Math.min(GH - 2, gy + r); y++) {\n            for (let x = Math.max(1, gx - r); x <= Math.min(GW - 2, gx + r); x++) {\n                const dx = x - gx;\n                const dy = y - gy;\n                const d2 = dx * dx + dy * dy;\n                if (d2 <= r * r) {\n                    cur[idx(x, y)] += amp;\n                }\n            }\n        }\n    }\n\n    export function step() {\n        for (let y = 1; y < GH - 1; y++) {\n            const yW = y * GW;\n            for (let x = 1; x < GW - 1; x++) {\n                const i = yW + x;\n                const sum = cur[i - 1] + cur[i + 1] + cur[i - GW] + cur[i + GW];\n                let n = (sum >> 1) - prev[i];\n                n = (n * DAMP_NUM) >> DAMP_SHIFT;\n                nextB[i] = n;\n            }\n        }\n        // rotate\n        const tmp = prev; prev = cur; cur = nextB; nextB = tmp;\n    }\n\n    export function sampleHeight(sx: number, sy: number): number {\n        const gx = sx * (GW - 1) / (screen.width - 1);\n        const gy = sy * (GH - 1) / (screen.height - 1);\n\n        const x0 = Math.max(0, Math.min(GW - 2, Math.floor(gx)));\n        const y0 = Math.max(0, Math.min(GH - 2, Math.floor(gy)));\n        const tx = gx - x0;\n        const ty = gy - y0;\n\n        const i00 = cur[idx(x0, y0)];\n        const i10 = cur[idx(x0 + 1, y0)];\n        const i01 = cur[idx(x0, y0 + 1)];\n        const i11 = cur[idx(x0 + 1, y0 + 1)];\n\n        const a = i00 * (1 - tx) + i10 * tx;\n        const b = i01 * (1 - tx) + i11 * tx;\n        const hFP = a * (1 - ty) + b * ty;\n\n        return (hFP / FP) / 2;\n    }\n}\n\nWaterSim.reset();\n\nbrowserEvents.onMouseMove(function(x: number, y: number) {\n    if (browserEvents.MouseLeft.isPressed()) {\n        WaterSim.splash(x, y, 1.0, 4);\n    }\n})\n\ngame.onUpdate(function () {\n    WaterSim.step();\n});\n\nconst checkerWaterShader: Shaders.Shader = (frag, u) => {\n    const h = WaterSim.sampleHeight(frag.x, frag.y);\n\n    const uvx = frag.x / u.resolution.x;\n    let uvy = frag.y / u.resolution.y + h * 0.15;\n\n    const tiles = 10;\n    const tx = Math.floor(uvx * tiles);\n    const ty = Math.floor(uvy * tiles);\n    const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n    let L = isWhite ? 0.9 : 0.1;\n    L += h * 0.5;\n\n    if (L < 0) L = 0;\n    if (L > 1) L = 1;\n\n    return L;\n};\n\nShaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\",\n        \"water_sim.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759523682954,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace Shaders {\" line1=\"    const exampleShader: Shader = (frag, u) =&gt; {\" line2=\"        const x = frag.x / u.resolution.x;\" line3=\"        const y = frag.y / u.resolution.y;\" line4=\"\" line5=\"        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\" line6=\"        return v &gt; 0 ? 0.2 : 0.8;\" line7=\"    };\" line8=\"\" line9=\"    const plasmaShader: Shaders.Shader = (frag, u) =&gt; {\" line10=\"        // normalize coordinates\" line11=\"        const nx = frag.x / u.resolution.x;\" line12=\"        const ny = frag.y / u.resolution.y;\" line13=\"\" line14=\"        // combine multiple sine waves\" line15=\"        const w =\" line16=\"            Math.sin(nx * 10 + u.time) +\" line17=\"            Math.sin((ny * 10) + u.time * 1.3) +\" line18=\"            Math.sin((nx + ny) * 10 + u.time * 0.7);\" line19=\"\" line20=\"        // normalize to 0..1\" line21=\"        const normalized = (w + 3) / 6;\" line22=\"\" line23=\"        // map to grayscale shade (1–15)\" line24=\"        return normalized;\" line25=\"    };\" line26=\"\" line27=\"    const rippleShader: Shaders.Shader = (frag, u) =&gt; {\" line28=\"        const cx = frag.x - u.resolution.x / 2;\" line29=\"        const cy = frag.y - u.resolution.y / 2;\" line30=\"        const dist = Math.sqrt(cx * cx + cy * cy);\" line31=\"\" line32=\"        const a = Math.sin(dist * 0.1 - u.time * 2);\" line33=\"        const normalized2 = (a + 1) / 2;\" line34=\"\" line35=\"        return normalized2;\" line36=\"    };\" line37=\"\" line38=\"    const tunnelShader: Shaders.Shader = (frag, u) =&gt; {\" line39=\"        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\" line40=\"        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\" line41=\"\" line42=\"        const angle = Math.atan2(ny2, nx2);\" line43=\"        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\" line44=\"\" line45=\"        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\" line46=\"        return (b + 1) / 2;\" line47=\"    };\" line48=\"\" line49=\"    const checkerShader: Shaders.Shader = (frag, u) =&gt; {\" line50=\"        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\" line51=\"\" line52=\"        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\" line53=\"        return c ? 1.0 : 0.0;\" line54=\"    };\" line55=\"\" line56=\"    const circlesShader: Shaders.Shader = (frag, u) =&gt; {\" line57=\"        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\" line58=\"        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\" line59=\"\" line60=\"        const dx = frag.x - cx2;\" line61=\"        const dy = frag.y - cy2;\" line62=\"        const dist3 = Math.sqrt(dx * dx + dy * dy);\" line63=\"\" line64=\"        const d = Math.sin(dist3 * 0.2 - u.time * 2);\" line65=\"        return (d + 1) / 2;\" line66=\"    };\" line67=\"\" line68=\"    const marbleShader: Shaders.Shader = (frag, u) =&gt; {\" line69=\"        const nx3 = frag.x / u.resolution.x;\" line70=\"        const ny3 = frag.y / u.resolution.y;\" line71=\"\" line72=\"        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\" line73=\"        return (e + 1) / 2;\" line74=\"    };\" line75=\"\" line76=\"    const marbleWithWobble: Shaders.Shader = (frag, u) =&gt; {\" line77=\"        // normalized UVs 0..1\" line78=\"        let uvx = frag.x / u.resolution.x;\" line79=\"        let uvy = frag.y / u.resolution.y;\" line80=\"\" line81=\"        // warp Y coordinate\" line82=\"        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\" line83=\"\" line84=\"        // base marble pattern\" line85=\"        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\" line86=\"\" line87=\"        // GLSL does (v + 1)/2 to map -1..1 → 0..1\" line88=\"        return (f + 1.0) * 0.5;\" line89=\"    };\" line90=\"\" line91=\"    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\" line92=\"        // center coords\" line93=\"        const cx3 = frag.x - u.resolution.x / 2;\" line94=\"        const cy3 = frag.y - u.resolution.y / 2;\" line95=\"        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\" line96=\"\" line97=\"        // ripple parameters\" line98=\"        const freq = 0.1;     // wave spacing\" line99=\"        const speed = 4.0;    // animation speed\" line100=\"        const baseAmp = 0.05; // base amplitude\" line101=\"\" line102=\"        // damping: amplitude decays with distance\" line103=\"        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\" line104=\"\" line105=\"        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\" line106=\"\" line107=\"        // normalized UVs\" line108=\"        const uvx2 = frag.x / u.resolution.x;\" line109=\"        let uvy2 = frag.y / u.resolution.y;\" line110=\"\" line111=\"        // apply vertical ripple distortion\" line112=\"        uvy2 += offset;\" line113=\"\" line114=\"        return new Shaders.Vec2(uvx2, uvy2);\" line115=\"    }\" line116=\"\" line117=\"    const marbleWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line118=\"        // ripple-distorted UVs\" line119=\"        const uv = rippleWarp(frag, u);\" line120=\"\" line121=\"        // marble pattern\" line122=\"        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\" line123=\"\" line124=\"        // normalize to 0..1\" line125=\"        return (g + 1.0) * 0.5;\" line126=\"    };\" line127=\"\" line128=\"    // Checkerboard + radial ripple (UV warp) + brightness shimmer\" line129=\"    // Phases for warp and shimmer are split so you can tune alignment.\" line130=\"\" line131=\"    const checkerWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line132=\"        // --- 1. Distance from screen center ---\" line133=\"        const dx2 = frag.x - u.resolution.x / 2;\" line134=\"        const dy2 = frag.y - u.resolution.y / 2;\" line135=\"        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\" line136=\"\" line137=\"        // --- 2. Base ripple parameters ---\" line138=\"        const freq2 = 0.12;                   // ripple spacing\" line139=\"        const speed2 = 3.0;                   // animation speed\" line140=\"        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\" line141=\"        const phase = dist5 * freq2 - u.time * speed2;\" line142=\"\" line143=\"        // --- 3. Warp the UVs (position ripple) ---\" line144=\"        const uvx3 = frag.x / u.resolution.x;\" line145=\"        let uvy3 = frag.y / u.resolution.y;\" line146=\"\" line147=\"        const warpAmp = 0.05;\" line148=\"        const wave = Math.sin(phase);\" line149=\"        uvy3 += wave * warpAmp * damping2;\" line150=\"\" line151=\"        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\" line152=\"        const tiles = 10;\" line153=\"        const tx = Math.floor(uvx3 * tiles);\" line154=\"        const ty = Math.floor(uvy3 * tiles);\" line155=\"        const isWhite = ((tx + ty) &amp; 1) ? 1 : 0;\" line156=\"\" line157=\"        const baseBlack = 0.1;\" line158=\"        const baseWhite = 0.9;\" line159=\"        const base = isWhite ? baseWhite : baseBlack;\" line160=\"\" line161=\"        // --- 5. Recalculate radial distance *after* warp ---\" line162=\"        const dx22 = frag.x - u.resolution.x / 2;\" line163=\"        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\" line164=\"        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\" line165=\"\" line166=\"        // --- 6. Shimmer based on warped radial distance ---\" line167=\"        const shimmerPhase = distWarped * freq2 - u.time * speed2;\" line168=\"        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\" line169=\"\" line170=\"        // --- 7. Combine and clamp ---\" line171=\"        let L = base + shimmer;\" line172=\"        if (L &lt; 0) L = 0;\" line173=\"        if (L &gt; 1) L = 1;\" line174=\"\" line175=\"        return L;\" line176=\"    };\" line177=\"\" line178=\"    interface Ripple {\" line179=\"        origin: Shaders.Vec2;\" line180=\"        startTime: number;\" line181=\"\" line182=\"        // precomputed each frame\" line183=\"        age?: number;\" line184=\"        waveDist?: number;\" line185=\"    }\" line186=\"\" line187=\"    let ripples: Ripple[] = [];\" line188=\"\" line189=\"    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\" line190=\"        ripples.push({\" line191=\"            origin: new Shaders.Vec2(x, y),\" line192=\"            startTime: game.runtime() / 1000\" line193=\"        });\" line194=\"    })\" line195=\"\" line196=\"    game.onUpdate(() =&gt; {\" line197=\"        const now = game.runtime() / 1000;\" line198=\"        ripples = ripples.filter(r =&gt; now - r.startTime &lt; 5); // keep last 5s\" line199=\"\" line200=\"        // precompute per-ripple values once per frame\" line201=\"        for (const r of ripples) {\" line202=\"            r.age = now - r.startTime;\" line203=\"            r.waveDist = r.age * 40; // speed in px/sec\" line204=\"        }\" line205=\"    });\" line206=\"\" line207=\"    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\" line208=\"        const dx3 = frag.x - r.origin.x;\" line209=\"        const dy3 = frag.y - r.origin.y;\" line210=\"        const dist22 = dx3 * dx3 + dy3 * dy3;\" line211=\"\" line212=\"        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\" line213=\"        const diff = dist6 - (r.waveDist || 0);\" line214=\"\" line215=\"        // cull if pixel is far from wavefront\" line216=\"        if (Math.abs(diff) &gt; 40) return 0;\" line217=\"\" line218=\"        // simple triangular falloff instead of exp()\" line219=\"        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\" line220=\"\" line221=\"        // cheap oscillation (precompute freq/speed if needed)\" line222=\"        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\" line223=\"    }\" line224=\"\" line225=\"    const checkerWithRippleClick: Shaders.Shader = (frag, u) =&gt; {\" line226=\"        // --- Checkerboard base ---\" line227=\"        const uvx4 = frag.x / u.resolution.x;\" line228=\"        const uvy4 = frag.y / u.resolution.y;\" line229=\"        const scale2 = 10;\" line230=\"        const tx2 = Math.floor(uvx4 * scale2);\" line231=\"        const ty2 = Math.floor(uvy4 * scale2);\" line232=\"        const isWhite2 = ((tx2 + ty2) &amp; 1) ? 1 : 0;\" line233=\"        const base2 = isWhite2 ? 0.9 : 0.1;\" line234=\"\" line235=\"        // --- Accumulate ripple contributions ---\" line236=\"        let rippleSum = 0;\" line237=\"        for (let i = 0; i &lt; ripples.length &amp;&amp; i &lt; 4; i++) {\" line238=\"            rippleSum += rippleContribution(frag, ripples[i]);\" line239=\"        }\" line240=\"\" line241=\"        // combine (tune ripple strength)\" line242=\"        let L2 = base2 + rippleSum;\" line243=\"\" line244=\"        // clamp\" line245=\"        if (L2 &lt; 0) L2 = 0;\" line246=\"        if (L2 &gt; 1) L2 = 1;\" line247=\"\" line248=\"        return L2;\" line249=\"    };\" line250=\"\" line251=\"    // initDefaults()\" line252=\"    // setActiveProgram((uniforms, screen) =&gt; {\" line253=\"    //     runShader(checkerWithRipple, screen, uniforms);\" line254=\"    // })\" line255=\"}\" numlines=\"256\"></mutation></block></statement></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const w =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (w + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const a = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized2 = (a + 1) / 2;\n\n        return normalized2;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny2, nx2);\n        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\n        return (b + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return c ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx2;\n        const dy = frag.y - cy2;\n        const dist3 = Math.sqrt(dx * dx + dy * dy);\n\n        const d = Math.sin(dist3 * 0.2 - u.time * 2);\n        return (d + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx3 = frag.x / u.resolution.x;\n        const ny3 = frag.y / u.resolution.y;\n\n        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\n        return (e + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (f + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx3 = frag.x - u.resolution.x / 2;\n        const cy3 = frag.y - u.resolution.y / 2;\n        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\n\n        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx2 = frag.x / u.resolution.x;\n        let uvy2 = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy2 += offset;\n\n        return new Shaders.Vec2(uvx2, uvy2);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (g + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- 1. Distance from screen center ---\n        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = frag.y - u.resolution.y / 2;\n        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        // --- 2. Base ripple parameters ---\n        const freq2 = 0.12;                   // ripple spacing\n        const speed2 = 3.0;                   // animation speed\n        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\n        const phase = dist5 * freq2 - u.time * speed2;\n\n        // --- 3. Warp the UVs (position ripple) ---\n        const uvx3 = frag.x / u.resolution.x;\n        let uvy3 = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy3 += wave * warpAmp * damping2;\n\n        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\n        const tiles = 10;\n        const tx = Math.floor(uvx3 * tiles);\n        const ty = Math.floor(uvy3 * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- 5. Recalculate radial distance *after* warp ---\n        const dx22 = frag.x - u.resolution.x / 2;\n        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\n\n        // --- 6. Shimmer based on warped radial distance ---\n        const shimmerPhase = distWarped * freq2 - u.time * speed2;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\n\n        // --- 7. Combine and clamp ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    interface Ripple {\n        origin: Shaders.Vec2;\n        startTime: number;\n\n        // precomputed each frame\n        age?: number;\n        waveDist?: number;\n    }\n\n    let ripples: Ripple[] = [];\n\n    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n        ripples.push({\n            origin: new Shaders.Vec2(x, y),\n            startTime: game.runtime() / 1000\n        });\n    })\n\n    game.onUpdate(() => {\n        const now = game.runtime() / 1000;\n        ripples = ripples.filter(r => now - r.startTime < 5); // keep last 5s\n\n        // precompute per-ripple values once per frame\n        for (const r of ripples) {\n            r.age = now - r.startTime;\n            r.waveDist = r.age * 40; // speed in px/sec\n        }\n    });\n\n    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\n        const dx3 = frag.x - r.origin.x;\n        const dy3 = frag.y - r.origin.y;\n        const dist22 = dx3 * dx3 + dy3 * dy3;\n\n        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\n        const diff = dist6 - (r.waveDist || 0);\n\n        // cull if pixel is far from wavefront\n        if (Math.abs(diff) > 40) return 0;\n\n        // simple triangular falloff instead of exp()\n        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\n\n        // cheap oscillation (precompute freq/speed if needed)\n        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n    }\n\n    const checkerWithRippleClick: Shaders.Shader = (frag, u) => {\n        // --- Checkerboard base ---\n        const uvx4 = frag.x / u.resolution.x;\n        const uvy4 = frag.y / u.resolution.y;\n        const scale2 = 10;\n        const tx2 = Math.floor(uvx4 * scale2);\n        const ty2 = Math.floor(uvy4 * scale2);\n        const isWhite2 = ((tx2 + ty2) & 1) ? 1 : 0;\n        const base2 = isWhite2 ? 0.9 : 0.1;\n\n        // --- Accumulate ripple contributions ---\n        let rippleSum = 0;\n        for (let i = 0; i < ripples.length && i < 4; i++) {\n            rippleSum += rippleContribution(frag, ripples[i]);\n        }\n\n        // combine (tune ripple strength)\n        let L2 = base2 + rippleSum;\n\n        // clamp\n        if (L2 < 0) L2 = 0;\n        if (L2 > 1) L2 = 1;\n\n        return L2;\n    };\n\n    // initDefaults()\n    // setActiveProgram((uniforms, screen) => {\n    //     runShader(checkerWithRipple, screen, uniforms);\n    // })\n}\n","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","water_sim.ts":"namespace WaterSim {\n    export const GW = 60;\n    export const GH = 45;\n    const FP = 256;\n\n    // Damping\n    const DAMP_NUM = 230;\n    const DAMP_SHIFT = 8;\n\n    // Pre-allocate buffers as plain number[] with fixed size\n    const SIZE = GW * GH;\n    let A: number[] = [];\n    let B: number[] = [];\n    let C: number[] = [];\n\n    // Manual initialization (no `new Array`)\n    export function init() {\n        A = [];\n        B = [];\n        C = [];\n        for (let i = 0; i < SIZE; i++) {\n            A.push(0);\n            B.push(0);\n            C.push(0);\n        }\n    }\n\n    let prev: number[];\n    let cur: number[];\n    let nextB: number[];\n\n    export function reset() {\n        init();\n        prev = A;\n        cur = B;\n        nextB = C;\n    }\n\n    function idx(x: number, y: number) { return y * GW + x; }\n\n    // Splash at screen coords\n    export function splash(sx: number, sy: number, strength = 1, radiusPx = 10) {\n        const gx = Math.idiv(sx * GW, screen.width);\n        const gy = Math.idiv(sy * GH, screen.height);\n        const r = Math.max(1, Math.idiv(radiusPx * GW, screen.width));\n\n        const amp = (strength * FP) | 0;\n\n        for (let y = Math.max(1, gy - r); y <= Math.min(GH - 2, gy + r); y++) {\n            for (let x = Math.max(1, gx - r); x <= Math.min(GW - 2, gx + r); x++) {\n                const dx = x - gx;\n                const dy = y - gy;\n                const d2 = dx * dx + dy * dy;\n                if (d2 <= r * r) {\n                    cur[idx(x, y)] += amp;\n                }\n            }\n        }\n    }\n\n    export function step() {\n        for (let y = 1; y < GH - 1; y++) {\n            const yW = y * GW;\n            for (let x = 1; x < GW - 1; x++) {\n                const i = yW + x;\n                const sum = cur[i - 1] + cur[i + 1] + cur[i - GW] + cur[i + GW];\n                let n = (sum >> 1) - prev[i];\n                n = (n * DAMP_NUM) >> DAMP_SHIFT;\n                nextB[i] = n;\n            }\n        }\n        // rotate\n        const tmp = prev; prev = cur; cur = nextB; nextB = tmp;\n    }\n\n    export function sampleHeight(sx: number, sy: number): number {\n        const gx = sx * (GW - 1) / (screen.width - 1);\n        const gy = sy * (GH - 1) / (screen.height - 1);\n\n        const x0 = Math.max(0, Math.min(GW - 2, Math.floor(gx)));\n        const y0 = Math.max(0, Math.min(GH - 2, Math.floor(gy)));\n        const tx = gx - x0;\n        const ty = gy - y0;\n\n        const i00 = cur[idx(x0, y0)];\n        const i10 = cur[idx(x0 + 1, y0)];\n        const i01 = cur[idx(x0, y0 + 1)];\n        const i11 = cur[idx(x0 + 1, y0 + 1)];\n\n        const a = i00 * (1 - tx) + i10 * tx;\n        const b = i01 * (1 - tx) + i11 * tx;\n        const hFP = a * (1 - ty) + b * ty;\n\n        return (hFP / FP) / 2;\n    }\n}\n\nWaterSim.reset();\n\nlet mouse = new Shaders.Vec2(80, 60)\nlet rippleOrigin = new Shaders.Vec2(80, 60)\n\nbrowserEvents.onMouseMove(function(x: number, y: number) {\n    mouse.x = x\n    mouse.y = y\n    if (browserEvents.MouseLeft.isPressed()) {\n        WaterSim.splash(rippleOrigin.x, rippleOrigin.y, 1.0, 4);\n    }\n})\n\ngame.onUpdate(function () {\n    WaterSim.step();\n    const move = mouse.sub(rippleOrigin).normalize().mul(5)\n    rippleOrigin = rippleOrigin.add(move)\n});\n\nconst checkerWaterShader: Shaders.Shader = (frag, u) => {\n    const h = WaterSim.sampleHeight(frag.x, frag.y);\n\n    const uvx = frag.x / u.resolution.x;\n    let uvy = frag.y / u.resolution.y + h * 0.15;\n\n    const tiles = 10;\n    const tx = Math.floor(uvx * tiles);\n    const ty = Math.floor(uvy * tiles);\n    const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n    let L = isWhite ? 0.9 : 0.1;\n    L += h * 0.5;\n\n    if (L < 0) L = 0;\n    if (L > 1) L = 1;\n\n    return L;\n};\n\nShaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7u4AAI6qqqqqqg7gqKqqqqqqDuCo7qqq7soO4Kjuqqruyg7gqqqqqqrKDgCuqqqqqswOAODu7u7u7gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-0\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\",\n        \"water_sim.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759526093010,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace Shaders {\" line1=\"    const exampleShader: Shader = (frag, u) =&gt; {\" line2=\"        const x = frag.x / u.resolution.x;\" line3=\"        const y = frag.y / u.resolution.y;\" line4=\"\" line5=\"        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\" line6=\"        return v &gt; 0 ? 0.2 : 0.8;\" line7=\"    };\" line8=\"\" line9=\"    const plasmaShader: Shaders.Shader = (frag, u) =&gt; {\" line10=\"        // normalize coordinates\" line11=\"        const nx = frag.x / u.resolution.x;\" line12=\"        const ny = frag.y / u.resolution.y;\" line13=\"\" line14=\"        // combine multiple sine waves\" line15=\"        const w =\" line16=\"            Math.sin(nx * 10 + u.time) +\" line17=\"            Math.sin((ny * 10) + u.time * 1.3) +\" line18=\"            Math.sin((nx + ny) * 10 + u.time * 0.7);\" line19=\"\" line20=\"        // normalize to 0..1\" line21=\"        const normalized = (w + 3) / 6;\" line22=\"\" line23=\"        // map to grayscale shade (1–15)\" line24=\"        return normalized;\" line25=\"    };\" line26=\"\" line27=\"    const rippleShader: Shaders.Shader = (frag, u) =&gt; {\" line28=\"        const cx = frag.x - u.resolution.x / 2;\" line29=\"        const cy = frag.y - u.resolution.y / 2;\" line30=\"        const dist = Math.sqrt(cx * cx + cy * cy);\" line31=\"\" line32=\"        const a = Math.sin(dist * 0.1 - u.time * 2);\" line33=\"        const normalized2 = (a + 1) / 2;\" line34=\"\" line35=\"        return normalized2;\" line36=\"    };\" line37=\"\" line38=\"    const tunnelShader: Shaders.Shader = (frag, u) =&gt; {\" line39=\"        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\" line40=\"        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\" line41=\"\" line42=\"        const angle = Math.atan2(ny2, nx2);\" line43=\"        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\" line44=\"\" line45=\"        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\" line46=\"        return (b + 1) / 2;\" line47=\"    };\" line48=\"\" line49=\"    const checkerShader: Shaders.Shader = (frag, u) =&gt; {\" line50=\"        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\" line51=\"\" line52=\"        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\" line53=\"        return c ? 1.0 : 0.0;\" line54=\"    };\" line55=\"\" line56=\"    const circlesShader: Shaders.Shader = (frag, u) =&gt; {\" line57=\"        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\" line58=\"        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\" line59=\"\" line60=\"        const dx = frag.x - cx2;\" line61=\"        const dy = frag.y - cy2;\" line62=\"        const dist3 = Math.sqrt(dx * dx + dy * dy);\" line63=\"\" line64=\"        const d = Math.sin(dist3 * 0.2 - u.time * 2);\" line65=\"        return (d + 1) / 2;\" line66=\"    };\" line67=\"\" line68=\"    const marbleShader: Shaders.Shader = (frag, u) =&gt; {\" line69=\"        const nx3 = frag.x / u.resolution.x;\" line70=\"        const ny3 = frag.y / u.resolution.y;\" line71=\"\" line72=\"        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\" line73=\"        return (e + 1) / 2;\" line74=\"    };\" line75=\"\" line76=\"    const marbleWithWobble: Shaders.Shader = (frag, u) =&gt; {\" line77=\"        // normalized UVs 0..1\" line78=\"        let uvx = frag.x / u.resolution.x;\" line79=\"        let uvy = frag.y / u.resolution.y;\" line80=\"\" line81=\"        // warp Y coordinate\" line82=\"        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\" line83=\"\" line84=\"        // base marble pattern\" line85=\"        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\" line86=\"\" line87=\"        // GLSL does (v + 1)/2 to map -1..1 → 0..1\" line88=\"        return (f + 1.0) * 0.5;\" line89=\"    };\" line90=\"\" line91=\"    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\" line92=\"        // center coords\" line93=\"        const cx3 = frag.x - u.resolution.x / 2;\" line94=\"        const cy3 = frag.y - u.resolution.y / 2;\" line95=\"        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\" line96=\"\" line97=\"        // ripple parameters\" line98=\"        const freq = 0.1;     // wave spacing\" line99=\"        const speed = 4.0;    // animation speed\" line100=\"        const baseAmp = 0.05; // base amplitude\" line101=\"\" line102=\"        // damping: amplitude decays with distance\" line103=\"        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\" line104=\"\" line105=\"        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\" line106=\"\" line107=\"        // normalized UVs\" line108=\"        const uvx2 = frag.x / u.resolution.x;\" line109=\"        let uvy2 = frag.y / u.resolution.y;\" line110=\"\" line111=\"        // apply vertical ripple distortion\" line112=\"        uvy2 += offset;\" line113=\"\" line114=\"        return new Shaders.Vec2(uvx2, uvy2);\" line115=\"    }\" line116=\"\" line117=\"    const marbleWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line118=\"        // ripple-distorted UVs\" line119=\"        const uv = rippleWarp(frag, u);\" line120=\"\" line121=\"        // marble pattern\" line122=\"        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\" line123=\"\" line124=\"        // normalize to 0..1\" line125=\"        return (g + 1.0) * 0.5;\" line126=\"    };\" line127=\"\" line128=\"    // Checkerboard + radial ripple (UV warp) + brightness shimmer\" line129=\"    // Phases for warp and shimmer are split so you can tune alignment.\" line130=\"\" line131=\"    const checkerWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line132=\"        // --- 1. Distance from screen center ---\" line133=\"        const dx2 = frag.x - u.resolution.x / 2;\" line134=\"        const dy2 = frag.y - u.resolution.y / 2;\" line135=\"        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\" line136=\"\" line137=\"        // --- 2. Base ripple parameters ---\" line138=\"        const freq2 = 0.12;                   // ripple spacing\" line139=\"        const speed2 = 3.0;                   // animation speed\" line140=\"        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\" line141=\"        const phase = dist5 * freq2 - u.time * speed2;\" line142=\"\" line143=\"        // --- 3. Warp the UVs (position ripple) ---\" line144=\"        const uvx3 = frag.x / u.resolution.x;\" line145=\"        let uvy3 = frag.y / u.resolution.y;\" line146=\"\" line147=\"        const warpAmp = 0.05;\" line148=\"        const wave = Math.sin(phase);\" line149=\"        uvy3 += wave * warpAmp * damping2;\" line150=\"\" line151=\"        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\" line152=\"        const tiles = 10;\" line153=\"        const tx = Math.floor(uvx3 * tiles);\" line154=\"        const ty = Math.floor(uvy3 * tiles);\" line155=\"        const isWhite = ((tx + ty) &amp; 1) ? 1 : 0;\" line156=\"\" line157=\"        const baseBlack = 0.1;\" line158=\"        const baseWhite = 0.9;\" line159=\"        const base = isWhite ? baseWhite : baseBlack;\" line160=\"\" line161=\"        // --- 5. Recalculate radial distance *after* warp ---\" line162=\"        const dx22 = frag.x - u.resolution.x / 2;\" line163=\"        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\" line164=\"        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\" line165=\"\" line166=\"        // --- 6. Shimmer based on warped radial distance ---\" line167=\"        const shimmerPhase = distWarped * freq2 - u.time * speed2;\" line168=\"        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\" line169=\"\" line170=\"        // --- 7. Combine and clamp ---\" line171=\"        let L = base + shimmer;\" line172=\"        if (L &lt; 0) L = 0;\" line173=\"        if (L &gt; 1) L = 1;\" line174=\"\" line175=\"        return L;\" line176=\"    };\" line177=\"\" line178=\"    interface Ripple {\" line179=\"        origin: Shaders.Vec2;\" line180=\"        startTime: number;\" line181=\"\" line182=\"        // precomputed each frame\" line183=\"        age?: number;\" line184=\"        waveDist?: number;\" line185=\"    }\" line186=\"\" line187=\"    let ripples: Ripple[] = [];\" line188=\"\" line189=\"    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\" line190=\"        ripples.push({\" line191=\"            origin: new Shaders.Vec2(x, y),\" line192=\"            startTime: game.runtime() / 1000\" line193=\"        });\" line194=\"    })\" line195=\"\" line196=\"    game.onUpdate(() =&gt; {\" line197=\"        const now = game.runtime() / 1000;\" line198=\"        ripples = ripples.filter(r =&gt; now - r.startTime &lt; 5); // keep last 5s\" line199=\"\" line200=\"        // precompute per-ripple values once per frame\" line201=\"        for (const r of ripples) {\" line202=\"            r.age = now - r.startTime;\" line203=\"            r.waveDist = r.age * 40; // speed in px/sec\" line204=\"        }\" line205=\"    });\" line206=\"\" line207=\"    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\" line208=\"        const dx3 = frag.x - r.origin.x;\" line209=\"        const dy3 = frag.y - r.origin.y;\" line210=\"        const dist22 = dx3 * dx3 + dy3 * dy3;\" line211=\"\" line212=\"        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\" line213=\"        const diff = dist6 - (r.waveDist || 0);\" line214=\"\" line215=\"        // cull if pixel is far from wavefront\" line216=\"        if (Math.abs(diff) &gt; 40) return 0;\" line217=\"\" line218=\"        // simple triangular falloff instead of exp()\" line219=\"        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\" line220=\"\" line221=\"        // cheap oscillation (precompute freq/speed if needed)\" line222=\"        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\" line223=\"    }\" line224=\"\" line225=\"    const checkerWithRippleClick: Shaders.Shader = (frag, u) =&gt; {\" line226=\"        // --- Checkerboard base ---\" line227=\"        const uvx4 = frag.x / u.resolution.x;\" line228=\"        const uvy4 = frag.y / u.resolution.y;\" line229=\"        const scale2 = 10;\" line230=\"        const tx2 = Math.floor(uvx4 * scale2);\" line231=\"        const ty2 = Math.floor(uvy4 * scale2);\" line232=\"        const isWhite2 = ((tx2 + ty2) &amp; 1) ? 1 : 0;\" line233=\"        const base2 = isWhite2 ? 0.9 : 0.1;\" line234=\"\" line235=\"        // --- Accumulate ripple contributions ---\" line236=\"        let rippleSum = 0;\" line237=\"        for (let i = 0; i &lt; ripples.length &amp;&amp; i &lt; 4; i++) {\" line238=\"            rippleSum += rippleContribution(frag, ripples[i]);\" line239=\"        }\" line240=\"\" line241=\"        // combine (tune ripple strength)\" line242=\"        let L2 = base2 + rippleSum;\" line243=\"\" line244=\"        // clamp\" line245=\"        if (L2 &lt; 0) L2 = 0;\" line246=\"        if (L2 &gt; 1) L2 = 1;\" line247=\"\" line248=\"        return L2;\" line249=\"    };\" line250=\"\" line251=\"    // initDefaults()\" line252=\"    // setActiveProgram((uniforms, screen) =&gt; {\" line253=\"    //     runShader(checkerWithRipple, screen, uniforms);\" line254=\"    // })\" line255=\"}\" numlines=\"256\"></mutation></block></statement></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const w =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (w + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const a = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized2 = (a + 1) / 2;\n\n        return normalized2;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny2, nx2);\n        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\n        return (b + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return c ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx2;\n        const dy = frag.y - cy2;\n        const dist3 = Math.sqrt(dx * dx + dy * dy);\n\n        const d = Math.sin(dist3 * 0.2 - u.time * 2);\n        return (d + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx3 = frag.x / u.resolution.x;\n        const ny3 = frag.y / u.resolution.y;\n\n        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\n        return (e + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (f + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx3 = frag.x - u.resolution.x / 2;\n        const cy3 = frag.y - u.resolution.y / 2;\n        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\n\n        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx2 = frag.x / u.resolution.x;\n        let uvy2 = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy2 += offset;\n\n        return new Shaders.Vec2(uvx2, uvy2);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (g + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- 1. Distance from screen center ---\n        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = frag.y - u.resolution.y / 2;\n        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        // --- 2. Base ripple parameters ---\n        const freq2 = 0.12;                   // ripple spacing\n        const speed2 = 3.0;                   // animation speed\n        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\n        const phase = dist5 * freq2 - u.time * speed2;\n\n        // --- 3. Warp the UVs (position ripple) ---\n        const uvx3 = frag.x / u.resolution.x;\n        let uvy3 = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy3 += wave * warpAmp * damping2;\n\n        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\n        const tiles = 10;\n        const tx = Math.floor(uvx3 * tiles);\n        const ty = Math.floor(uvy3 * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- 5. Recalculate radial distance *after* warp ---\n        const dx22 = frag.x - u.resolution.x / 2;\n        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\n\n        // --- 6. Shimmer based on warped radial distance ---\n        const shimmerPhase = distWarped * freq2 - u.time * speed2;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\n\n        // --- 7. Combine and clamp ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    interface Ripple {\n        origin: Shaders.Vec2;\n        startTime: number;\n\n        // precomputed each frame\n        age?: number;\n        waveDist?: number;\n    }\n\n    let ripples: Ripple[] = [];\n\n    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n        ripples.push({\n            origin: new Shaders.Vec2(x, y),\n            startTime: game.runtime() / 1000\n        });\n    })\n\n    game.onUpdate(() => {\n        const now = game.runtime() / 1000;\n        ripples = ripples.filter(r => now - r.startTime < 5); // keep last 5s\n\n        // precompute per-ripple values once per frame\n        for (const r of ripples) {\n            r.age = now - r.startTime;\n            r.waveDist = r.age * 40; // speed in px/sec\n        }\n    });\n\n    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\n        const dx3 = frag.x - r.origin.x;\n        const dy3 = frag.y - r.origin.y;\n        const dist22 = dx3 * dx3 + dy3 * dy3;\n\n        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\n        const diff = dist6 - (r.waveDist || 0);\n\n        // cull if pixel is far from wavefront\n        if (Math.abs(diff) > 40) return 0;\n\n        // simple triangular falloff instead of exp()\n        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\n\n        // cheap oscillation (precompute freq/speed if needed)\n        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n    }\n\n    const checkerWithRippleClick: Shaders.Shader = (frag, u) => {\n        // --- Checkerboard base ---\n        const uvx4 = frag.x / u.resolution.x;\n        const uvy4 = frag.y / u.resolution.y;\n        const scale2 = 10;\n        const tx2 = Math.floor(uvx4 * scale2);\n        const ty2 = Math.floor(uvy4 * scale2);\n        const isWhite2 = ((tx2 + ty2) & 1) ? 1 : 0;\n        const base2 = isWhite2 ? 0.9 : 0.1;\n\n        // --- Accumulate ripple contributions ---\n        let rippleSum = 0;\n        for (let i = 0; i < ripples.length && i < 4; i++) {\n            rippleSum += rippleContribution(frag, ripples[i]);\n        }\n\n        // combine (tune ripple strength)\n        let L2 = base2 + rippleSum;\n\n        // clamp\n        if (L2 < 0) L2 = 0;\n        if (L2 > 1) L2 = 1;\n\n        return L2;\n    };\n\n    // initDefaults()\n    // setActiveProgram((uniforms, screen) => {\n    //     runShader(checkerWithRipple, screen, uniforms);\n    // })\n}\n","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","water_sim.ts":"namespace WaterSim {\n    export const GW = 60;\n    export const GH = 45;\n    const FP = 256;\n\n    // Damping\n    const DAMP_NUM = 230;\n    const DAMP_SHIFT = 8;\n\n    // Pre-allocate buffers as plain number[] with fixed size\n    const SIZE = GW * GH;\n    let A: number[] = [];\n    let B: number[] = [];\n    let C: number[] = [];\n\n    // Manual initialization (no `new Array`)\n    export function init() {\n        A = [];\n        B = [];\n        C = [];\n        for (let i = 0; i < SIZE; i++) {\n            A.push(0);\n            B.push(0);\n            C.push(0);\n        }\n    }\n\n    let prev: number[];\n    let cur: number[];\n    let nextB: number[];\n\n    export function reset() {\n        init();\n        prev = A;\n        cur = B;\n        nextB = C;\n    }\n\n    function idx(x: number, y: number) { return y * GW + x; }\n\n    // Splash at screen coords\n    export function splash(sx: number, sy: number, strength = 1, radiusPx = 10) {\n        const gx = Math.idiv(sx * GW, screen.width);\n        const gy = Math.idiv(sy * GH, screen.height);\n        const r = Math.max(1, Math.idiv(radiusPx * GW, screen.width));\n\n        const amp = (strength * FP) | 0;\n\n        for (let y = Math.max(1, gy - r); y <= Math.min(GH - 2, gy + r); y++) {\n            for (let x = Math.max(1, gx - r); x <= Math.min(GW - 2, gx + r); x++) {\n                const dx = x - gx;\n                const dy = y - gy;\n                const d2 = dx * dx + dy * dy;\n                if (d2 <= r * r) {\n                    cur[idx(x, y)] += amp;\n                }\n            }\n        }\n    }\n\n    export function step() {\n        for (let y = 1; y < GH - 1; y++) {\n            const yW = y * GW;\n            for (let x = 1; x < GW - 1; x++) {\n                const i = yW + x;\n                const sum = cur[i - 1] + cur[i + 1] + cur[i - GW] + cur[i + GW];\n                let n = (sum >> 1) - prev[i];\n                n = (n * DAMP_NUM) >> DAMP_SHIFT;\n                nextB[i] = n;\n            }\n        }\n        // rotate\n        const tmp = prev; prev = cur; cur = nextB; nextB = tmp;\n    }\n\n    export function sampleHeight(sx: number, sy: number): number {\n        const gx = sx * (GW - 1) / (screen.width - 1);\n        const gy = sy * (GH - 1) / (screen.height - 1);\n\n        const x0 = Math.max(0, Math.min(GW - 2, Math.floor(gx)));\n        const y0 = Math.max(0, Math.min(GH - 2, Math.floor(gy)));\n        const tx = gx - x0;\n        const ty = gy - y0;\n\n        const i00 = cur[idx(x0, y0)];\n        const i10 = cur[idx(x0 + 1, y0)];\n        const i01 = cur[idx(x0, y0 + 1)];\n        const i11 = cur[idx(x0 + 1, y0 + 1)];\n\n        const a = i00 * (1 - tx) + i10 * tx;\n        const b = i01 * (1 - tx) + i11 * tx;\n        const hFP = a * (1 - ty) + b * ty;\n\n        return (hFP / FP) / 2;\n    }\n}\n\nWaterSim.reset();\n\nlet mouse = new Shaders.Vec2(80, 60)\nlet rippleOrigin = new Shaders.Vec2(80, 60)\n\nbrowserEvents.onMouseMove(function(x: number, y: number) {\n    mouse.x = x\n    mouse.y = y\n    if (browserEvents.MouseLeft.isPressed()) {\n        WaterSim.splash(rippleOrigin.x, rippleOrigin.y, 1.0, 4);\n    }\n})\n\ngame.onUpdate(function () {\n    WaterSim.step();\n    const move = mouse.sub(rippleOrigin).normalize().mul(5)\n    rippleOrigin = rippleOrigin.add(move)\n});\n\nconst checkerWaterShader: Shaders.Shader = (frag, u) => {\n    const h = WaterSim.sampleHeight(frag.x, frag.y);\n\n    const uvx = frag.x / u.resolution.x;\n    let uvy = frag.y / u.resolution.y + h * 0.15;\n\n    const tiles = 10;\n    const tx = Math.floor(uvx * tiles);\n    const ty = Math.floor(uvy * tiles);\n    const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n    let L = isWhite ? 0.9 : 0.1;\n    L += h * 0.5;\n\n    if (L < 0) L = 0;\n    if (L > 1) L = 1;\n\n    return L;\n};\n\nShaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})","images.g.jres":"{\n    \"image3\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAODuDgAAAAAArursAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACurs4AAAAAAK6uzgAAAAAArq7OAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAOCq7gAAAAAAAO4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-90\"\n    },\n    \"image4\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAADuDgAAAAAA4KruAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK6uzgAAAAAArq7OAAAAAACurs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK7q7AAAAAAA4O4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-270\"\n    },\n    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gAArqqqqqqqDgCuququqqoOAK6q6q6qqg4ArqqqqqqqDgCuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-180\"\n    },\n    \"image5\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODOAAAAAAAAruoMAAAAAOCqqs4AAAAArqqq6gwAAOCqqqrqDAAAruquqs4MAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAK6qqs4MAAAArqrqzAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-45\"\n    },\n    \"image6\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqzAAAAACuqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgwAAOCqqqrqDAAAAK6qquoMAAAA4KqqzgAAAAAAruoMAAAAAADgzgAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-315\"\n    },\n    \"image7\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqDAAAAOCqquoMAAAArqqq6gwAAOCqqqrqDAAAruquqs4AAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAOCqqs4MAAAAAK7qzAAAAAAA4M4MAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-225\"\n    },\n    \"image8\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAADgzgwAAAAAAK7qzAAAAADgqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgAAAOCqqqrqDAAAAK6qquoMAAAA4Kqq6gwAAAAArqrqDAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-135\"\n    },\n    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gDgqqqqqqrqAOCqquququoA4Kqq6q6q6gDgqqqqqqrqAACuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-0\"\n    },\n    \"anim1\": {\n        \"namespace\": \"myAnimations\",\n        \"id\": \"anim1\",\n        \"mimeType\": \"application/mkcd-animation\",\n        \"data\": \"NTAwMDEwMDAxMDAwMDUwMDAwMDAwMDYwNjYwMDAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjY2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDA2NjAwNjAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwNjAwMDAwMDAwMDAwMGMwNjAwMDAwMDAwMDAwMDBjMDA2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjAwMDYwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDYwMDAwMDAwMDAwMDBjMDYwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjY2MDYwMDAwMDAwMGMwNjYwNjAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwMDYwMDAwMDAwMDAwMDBjMDY2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\",\n        \"displayName\": \"myAnim\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\",\n        \"water_sim.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759541792369,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace Shaders {\" line1=\"    const exampleShader: Shader = (frag, u) =&gt; {\" line2=\"        const x = frag.x / u.resolution.x;\" line3=\"        const y = frag.y / u.resolution.y;\" line4=\"\" line5=\"        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\" line6=\"        return v &gt; 0 ? 0.2 : 0.8;\" line7=\"    };\" line8=\"\" line9=\"    const plasmaShader: Shaders.Shader = (frag, u) =&gt; {\" line10=\"        // normalize coordinates\" line11=\"        const nx = frag.x / u.resolution.x;\" line12=\"        const ny = frag.y / u.resolution.y;\" line13=\"\" line14=\"        // combine multiple sine waves\" line15=\"        const w =\" line16=\"            Math.sin(nx * 10 + u.time) +\" line17=\"            Math.sin((ny * 10) + u.time * 1.3) +\" line18=\"            Math.sin((nx + ny) * 10 + u.time * 0.7);\" line19=\"\" line20=\"        // normalize to 0..1\" line21=\"        const normalized = (w + 3) / 6;\" line22=\"\" line23=\"        // map to grayscale shade (1–15)\" line24=\"        return normalized;\" line25=\"    };\" line26=\"\" line27=\"    const rippleShader: Shaders.Shader = (frag, u) =&gt; {\" line28=\"        const cx = frag.x - u.resolution.x / 2;\" line29=\"        const cy = frag.y - u.resolution.y / 2;\" line30=\"        const dist = Math.sqrt(cx * cx + cy * cy);\" line31=\"\" line32=\"        const a = Math.sin(dist * 0.1 - u.time * 2);\" line33=\"        const normalized2 = (a + 1) / 2;\" line34=\"\" line35=\"        return normalized2;\" line36=\"    };\" line37=\"\" line38=\"    const tunnelShader: Shaders.Shader = (frag, u) =&gt; {\" line39=\"        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\" line40=\"        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\" line41=\"\" line42=\"        const angle = Math.atan2(ny2, nx2);\" line43=\"        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\" line44=\"\" line45=\"        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\" line46=\"        return (b + 1) / 2;\" line47=\"    };\" line48=\"\" line49=\"    const checkerShader: Shaders.Shader = (frag, u) =&gt; {\" line50=\"        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\" line51=\"\" line52=\"        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\" line53=\"        return c ? 1.0 : 0.0;\" line54=\"    };\" line55=\"\" line56=\"    const circlesShader: Shaders.Shader = (frag, u) =&gt; {\" line57=\"        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\" line58=\"        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\" line59=\"\" line60=\"        const dx = frag.x - cx2;\" line61=\"        const dy = frag.y - cy2;\" line62=\"        const dist3 = Math.sqrt(dx * dx + dy * dy);\" line63=\"\" line64=\"        const d = Math.sin(dist3 * 0.2 - u.time * 2);\" line65=\"        return (d + 1) / 2;\" line66=\"    };\" line67=\"\" line68=\"    const marbleShader: Shaders.Shader = (frag, u) =&gt; {\" line69=\"        const nx3 = frag.x / u.resolution.x;\" line70=\"        const ny3 = frag.y / u.resolution.y;\" line71=\"\" line72=\"        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\" line73=\"        return (e + 1) / 2;\" line74=\"    };\" line75=\"\" line76=\"    const marbleWithWobble: Shaders.Shader = (frag, u) =&gt; {\" line77=\"        // normalized UVs 0..1\" line78=\"        let uvx = frag.x / u.resolution.x;\" line79=\"        let uvy = frag.y / u.resolution.y;\" line80=\"\" line81=\"        // warp Y coordinate\" line82=\"        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\" line83=\"\" line84=\"        // base marble pattern\" line85=\"        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\" line86=\"\" line87=\"        // GLSL does (v + 1)/2 to map -1..1 → 0..1\" line88=\"        return (f + 1.0) * 0.5;\" line89=\"    };\" line90=\"\" line91=\"    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\" line92=\"        // center coords\" line93=\"        const cx3 = frag.x - u.resolution.x / 2;\" line94=\"        const cy3 = frag.y - u.resolution.y / 2;\" line95=\"        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\" line96=\"\" line97=\"        // ripple parameters\" line98=\"        const freq = 0.1;     // wave spacing\" line99=\"        const speed = 4.0;    // animation speed\" line100=\"        const baseAmp = 0.05; // base amplitude\" line101=\"\" line102=\"        // damping: amplitude decays with distance\" line103=\"        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\" line104=\"\" line105=\"        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\" line106=\"\" line107=\"        // normalized UVs\" line108=\"        const uvx2 = frag.x / u.resolution.x;\" line109=\"        let uvy2 = frag.y / u.resolution.y;\" line110=\"\" line111=\"        // apply vertical ripple distortion\" line112=\"        uvy2 += offset;\" line113=\"\" line114=\"        return new Shaders.Vec2(uvx2, uvy2);\" line115=\"    }\" line116=\"\" line117=\"    const marbleWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line118=\"        // ripple-distorted UVs\" line119=\"        const uv = rippleWarp(frag, u);\" line120=\"\" line121=\"        // marble pattern\" line122=\"        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\" line123=\"\" line124=\"        // normalize to 0..1\" line125=\"        return (g + 1.0) * 0.5;\" line126=\"    };\" line127=\"\" line128=\"    // Checkerboard + radial ripple (UV warp) + brightness shimmer\" line129=\"    // Phases for warp and shimmer are split so you can tune alignment.\" line130=\"\" line131=\"    const checkerWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line132=\"        // --- 1. Distance from screen center ---\" line133=\"        const dx2 = frag.x - u.resolution.x / 2;\" line134=\"        const dy2 = frag.y - u.resolution.y / 2;\" line135=\"        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\" line136=\"\" line137=\"        // --- 2. Base ripple parameters ---\" line138=\"        const freq2 = 0.12;                   // ripple spacing\" line139=\"        const speed2 = 3.0;                   // animation speed\" line140=\"        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\" line141=\"        const phase = dist5 * freq2 - u.time * speed2;\" line142=\"\" line143=\"        // --- 3. Warp the UVs (position ripple) ---\" line144=\"        const uvx3 = frag.x / u.resolution.x;\" line145=\"        let uvy3 = frag.y / u.resolution.y;\" line146=\"\" line147=\"        const warpAmp = 0.05;\" line148=\"        const wave = Math.sin(phase);\" line149=\"        uvy3 += wave * warpAmp * damping2;\" line150=\"\" line151=\"        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\" line152=\"        const tiles = 10;\" line153=\"        const tx = Math.floor(uvx3 * tiles);\" line154=\"        const ty = Math.floor(uvy3 * tiles);\" line155=\"        const isWhite = ((tx + ty) &amp; 1) ? 1 : 0;\" line156=\"\" line157=\"        const baseBlack = 0.1;\" line158=\"        const baseWhite = 0.9;\" line159=\"        const base = isWhite ? baseWhite : baseBlack;\" line160=\"\" line161=\"        // --- 5. Recalculate radial distance *after* warp ---\" line162=\"        const dx22 = frag.x - u.resolution.x / 2;\" line163=\"        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\" line164=\"        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\" line165=\"\" line166=\"        // --- 6. Shimmer based on warped radial distance ---\" line167=\"        const shimmerPhase = distWarped * freq2 - u.time * speed2;\" line168=\"        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\" line169=\"\" line170=\"        // --- 7. Combine and clamp ---\" line171=\"        let L = base + shimmer;\" line172=\"        if (L &lt; 0) L = 0;\" line173=\"        if (L &gt; 1) L = 1;\" line174=\"\" line175=\"        return L;\" line176=\"    };\" line177=\"\" line178=\"    interface Ripple {\" line179=\"        origin: Shaders.Vec2;\" line180=\"        startTime: number;\" line181=\"\" line182=\"        // precomputed each frame\" line183=\"        age?: number;\" line184=\"        waveDist?: number;\" line185=\"    }\" line186=\"\" line187=\"    let ripples: Ripple[] = [];\" line188=\"\" line189=\"    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\" line190=\"        ripples.push({\" line191=\"            origin: new Shaders.Vec2(x, y),\" line192=\"            startTime: game.runtime() / 1000\" line193=\"        });\" line194=\"    })\" line195=\"\" line196=\"    game.onUpdate(() =&gt; {\" line197=\"        const now = game.runtime() / 1000;\" line198=\"        ripples = ripples.filter(r =&gt; now - r.startTime &lt; 5); // keep last 5s\" line199=\"\" line200=\"        // precompute per-ripple values once per frame\" line201=\"        for (const r of ripples) {\" line202=\"            r.age = now - r.startTime;\" line203=\"            r.waveDist = r.age * 40; // speed in px/sec\" line204=\"        }\" line205=\"    });\" line206=\"\" line207=\"    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\" line208=\"        const dx3 = frag.x - r.origin.x;\" line209=\"        const dy3 = frag.y - r.origin.y;\" line210=\"        const dist22 = dx3 * dx3 + dy3 * dy3;\" line211=\"\" line212=\"        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\" line213=\"        const diff = dist6 - (r.waveDist || 0);\" line214=\"\" line215=\"        // cull if pixel is far from wavefront\" line216=\"        if (Math.abs(diff) &gt; 40) return 0;\" line217=\"\" line218=\"        // simple triangular falloff instead of exp()\" line219=\"        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\" line220=\"\" line221=\"        // cheap oscillation (precompute freq/speed if needed)\" line222=\"        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\" line223=\"    }\" line224=\"\" line225=\"    const checkerWithRippleClick: Shaders.Shader = (frag, u) =&gt; {\" line226=\"        // --- Checkerboard base ---\" line227=\"        const uvx4 = frag.x / u.resolution.x;\" line228=\"        const uvy4 = frag.y / u.resolution.y;\" line229=\"        const scale2 = 10;\" line230=\"        const tx2 = Math.floor(uvx4 * scale2);\" line231=\"        const ty2 = Math.floor(uvy4 * scale2);\" line232=\"        const isWhite2 = ((tx2 + ty2) &amp; 1) ? 1 : 0;\" line233=\"        const base2 = isWhite2 ? 0.9 : 0.1;\" line234=\"\" line235=\"        // --- Accumulate ripple contributions ---\" line236=\"        let rippleSum = 0;\" line237=\"        for (let i = 0; i &lt; ripples.length &amp;&amp; i &lt; 4; i++) {\" line238=\"            rippleSum += rippleContribution(frag, ripples[i]);\" line239=\"        }\" line240=\"\" line241=\"        // combine (tune ripple strength)\" line242=\"        let L2 = base2 + rippleSum;\" line243=\"\" line244=\"        // clamp\" line245=\"        if (L2 &lt; 0) L2 = 0;\" line246=\"        if (L2 &gt; 1) L2 = 1;\" line247=\"\" line248=\"        return L2;\" line249=\"    };\" line250=\"\" line251=\"    // initDefaults()\" line252=\"    // setActiveProgram((uniforms, screen) =&gt; {\" line253=\"    //     runShader(checkerWithRipple, screen, uniforms);\" line254=\"    // })\" line255=\"}\" numlines=\"256\"></mutation></block></statement></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const w =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (w + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const a = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized2 = (a + 1) / 2;\n\n        return normalized2;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny2, nx2);\n        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\n        return (b + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return c ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx2;\n        const dy = frag.y - cy2;\n        const dist3 = Math.sqrt(dx * dx + dy * dy);\n\n        const d = Math.sin(dist3 * 0.2 - u.time * 2);\n        return (d + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx3 = frag.x / u.resolution.x;\n        const ny3 = frag.y / u.resolution.y;\n\n        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\n        return (e + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (f + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx3 = frag.x - u.resolution.x / 2;\n        const cy3 = frag.y - u.resolution.y / 2;\n        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\n\n        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx2 = frag.x / u.resolution.x;\n        let uvy2 = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy2 += offset;\n\n        return new Shaders.Vec2(uvx2, uvy2);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (g + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- 1. Distance from screen center ---\n        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = frag.y - u.resolution.y / 2;\n        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        // --- 2. Base ripple parameters ---\n        const freq2 = 0.12;                   // ripple spacing\n        const speed2 = 3.0;                   // animation speed\n        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\n        const phase = dist5 * freq2 - u.time * speed2;\n\n        // --- 3. Warp the UVs (position ripple) ---\n        const uvx3 = frag.x / u.resolution.x;\n        let uvy3 = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy3 += wave * warpAmp * damping2;\n\n        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\n        const tiles = 10;\n        const tx = Math.floor(uvx3 * tiles);\n        const ty = Math.floor(uvy3 * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- 5. Recalculate radial distance *after* warp ---\n        const dx22 = frag.x - u.resolution.x / 2;\n        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\n\n        // --- 6. Shimmer based on warped radial distance ---\n        const shimmerPhase = distWarped * freq2 - u.time * speed2;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\n\n        // --- 7. Combine and clamp ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    interface Ripple {\n        origin: Shaders.Vec2;\n        startTime: number;\n\n        // precomputed each frame\n        age?: number;\n        waveDist?: number;\n    }\n\n    let ripples: Ripple[] = [];\n\n    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n        ripples.push({\n            origin: new Shaders.Vec2(x, y),\n            startTime: game.runtime() / 1000\n        });\n    })\n\n    game.onUpdate(() => {\n        const now = game.runtime() / 1000;\n        ripples = ripples.filter(r => now - r.startTime < 5); // keep last 5s\n\n        // precompute per-ripple values once per frame\n        for (const r of ripples) {\n            r.age = now - r.startTime;\n            r.waveDist = r.age * 40; // speed in px/sec\n        }\n    });\n\n    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\n        const dx3 = frag.x - r.origin.x;\n        const dy3 = frag.y - r.origin.y;\n        const dist22 = dx3 * dx3 + dy3 * dy3;\n\n        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\n        const diff = dist6 - (r.waveDist || 0);\n\n        // cull if pixel is far from wavefront\n        if (Math.abs(diff) > 40) return 0;\n\n        // simple triangular falloff instead of exp()\n        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\n\n        // cheap oscillation (precompute freq/speed if needed)\n        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n    }\n\n    const checkerWithRippleClick: Shaders.Shader = (frag, u) => {\n        // --- Checkerboard base ---\n        const uvx4 = frag.x / u.resolution.x;\n        const uvy4 = frag.y / u.resolution.y;\n        const scale2 = 10;\n        const tx2 = Math.floor(uvx4 * scale2);\n        const ty2 = Math.floor(uvy4 * scale2);\n        const isWhite2 = ((tx2 + ty2) & 1) ? 1 : 0;\n        const base2 = isWhite2 ? 0.9 : 0.1;\n\n        // --- Accumulate ripple contributions ---\n        let rippleSum = 0;\n        for (let i = 0; i < ripples.length && i < 4; i++) {\n            rippleSum += rippleContribution(frag, ripples[i]);\n        }\n\n        // combine (tune ripple strength)\n        let L2 = base2 + rippleSum;\n\n        // clamp\n        if (L2 < 0) L2 = 0;\n        if (L2 > 1) L2 = 1;\n\n        return L2;\n    };\n\n    // initDefaults()\n    // setActiveProgram((uniforms, screen) => {\n    //     runShader(checkerWithRipple, screen, uniforms);\n    // })\n}\n","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","water_sim.ts":"namespace WaterSim {\n    export const GW = 60;\n    export const GH = 45;\n    const FP = 256;\n\n    // Damping\n    const DAMP_NUM = 230;\n    const DAMP_SHIFT = 8;\n\n    // Pre-allocate buffers as plain number[] with fixed size\n    const SIZE = GW * GH;\n    let A: number[] = [];\n    let B: number[] = [];\n    let C: number[] = [];\n\n    // Manual initialization (no `new Array`)\n    export function init() {\n        A = [];\n        B = [];\n        C = [];\n        for (let i = 0; i < SIZE; i++) {\n            A.push(0);\n            B.push(0);\n            C.push(0);\n        }\n    }\n\n    let prev: number[];\n    let cur: number[];\n    let nextB: number[];\n\n    export function reset() {\n        init();\n        prev = A;\n        cur = B;\n        nextB = C;\n    }\n\n    function idx(x: number, y: number) { return y * GW + x; }\n\n    // Splash at screen coords\n    export function splash(sx: number, sy: number, strength = 1, radiusPx = 10) {\n        const gx = Math.idiv(sx * GW, screen.width);\n        const gy = Math.idiv(sy * GH, screen.height);\n        const r = Math.max(1, Math.idiv(radiusPx * GW, screen.width));\n\n        const amp = (strength * FP) | 0;\n\n        for (let y = Math.max(1, gy - r); y <= Math.min(GH - 2, gy + r); y++) {\n            for (let x = Math.max(1, gx - r); x <= Math.min(GW - 2, gx + r); x++) {\n                const dx = x - gx;\n                const dy = y - gy;\n                const d2 = dx * dx + dy * dy;\n                if (d2 <= r * r) {\n                    cur[idx(x, y)] += amp;\n                }\n            }\n        }\n    }\n\n    export function step() {\n        for (let y = 1; y < GH - 1; y++) {\n            const yW = y * GW;\n            for (let x = 1; x < GW - 1; x++) {\n                const i = yW + x;\n                const sum = cur[i - 1] + cur[i + 1] + cur[i - GW] + cur[i + GW];\n                let n = (sum >> 1) - prev[i];\n                n = (n * DAMP_NUM) >> DAMP_SHIFT;\n                nextB[i] = n;\n            }\n        }\n        // rotate\n        const tmp = prev; prev = cur; cur = nextB; nextB = tmp;\n    }\n\n    export function sampleHeight(sx: number, sy: number): number {\n        const gx = sx * (GW - 1) / (screen.width - 1);\n        const gy = sy * (GH - 1) / (screen.height - 1);\n\n        const x0 = Math.max(0, Math.min(GW - 2, Math.floor(gx)));\n        const y0 = Math.max(0, Math.min(GH - 2, Math.floor(gy)));\n        const tx = gx - x0;\n        const ty = gy - y0;\n\n        const i00 = cur[idx(x0, y0)];\n        const i10 = cur[idx(x0 + 1, y0)];\n        const i01 = cur[idx(x0, y0 + 1)];\n        const i11 = cur[idx(x0 + 1, y0 + 1)];\n\n        const a = i00 * (1 - tx) + i10 * tx;\n        const b = i01 * (1 - tx) + i11 * tx;\n        const hFP = a * (1 - ty) + b * ty;\n\n        return (hFP / FP) / 2;\n    }\n}\n\nWaterSim.reset();\n\nlet mouse = new Shaders.Vec2(80, 60)\nlet rippleOrigin = new Shaders.Vec2(80, 60)\nlet boat = sprites.create(assets.image`boat0`)\n\nbrowserEvents.onMouseMove(function(x: number, y: number) {\n    mouse.x = x\n    mouse.y = y\n    if (browserEvents.MouseLeft.isPressed()) {\n        WaterSim.splash(rippleOrigin.x, rippleOrigin.y, 1.0, 4);\n    }\n})\n\ngame.onUpdate(function () {\n    WaterSim.step();\n    const move = mouse.sub(rippleOrigin).normalize().mul(5)\n    rippleOrigin = rippleOrigin.add(move)\n\n});\n\nconst checkerWaterShader: Shaders.Shader = (frag, u) => {\n    const h = WaterSim.sampleHeight(frag.x, frag.y);\n\n    const uvx = frag.x / u.resolution.x;\n    let uvy = frag.y / u.resolution.y + h * 0.15;\n\n    const tiles = 10;\n    const tx = Math.floor(uvx * tiles);\n    const ty = Math.floor(uvy * tiles);\n    const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n    let L = isWhite ? 0.9 : 0.1;\n    L += h * 0.5;\n\n    if (L < 0) L = 0;\n    if (L > 1) L = 1;\n\n    return L;\n};\n\nShaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})","images.g.jres":"{\n    \"image3\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAODuDgAAAAAArursAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACurs4AAAAAAK6uzgAAAAAArq7OAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAOCq7gAAAAAAAO4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-90\"\n    },\n    \"image4\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAADuDgAAAAAA4KruAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK6uzgAAAAAArq7OAAAAAACurs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK7q7AAAAAAA4O4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-270\"\n    },\n    \"image5\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODOAAAAAAAAruoMAAAAAOCqqs4AAAAArqqq6gwAAOCqqqrqDAAAruquqs4MAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAK6qqs4MAAAArqrqzAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-45\"\n    },\n    \"image6\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqzAAAAACuqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgwAAOCqqqrqDAAAAK6qquoMAAAA4KqqzgAAAAAAruoMAAAAAADgzgAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-315\"\n    },\n    \"image7\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqDAAAAOCqquoMAAAArqqq6gwAAOCqqqrqDAAAruquqs4AAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAOCqqs4MAAAAAK7qzAAAAAAA4M4MAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-225\"\n    },\n    \"image8\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAADgzgwAAAAAAK7qzAAAAADgqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgAAAOCqqqrqDAAAAK6qquoMAAAA4Kqq6gwAAAAArqrqDAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-135\"\n    },\n    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gDgqqqqqqrqAOCqquququoA4Kqq6q6q6gDgqqqqqqrqAACuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat0\"\n    },\n    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gAArqqqqqqqDgCuququqqoOAK6q6q6qqg4ArqqqqqqqDgCuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat180\"\n    },\n    \"anim1\": {\n        \"namespace\": \"myAnimations\",\n        \"id\": \"anim1\",\n        \"mimeType\": \"application/mkcd-animation\",\n        \"data\": \"NTAwMDEwMDAxMDAwMDUwMDAwMDAwMDYwNjYwMDAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjY2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDA2NjAwNjAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwNjAwMDAwMDAwMDAwMGMwNjAwMDAwMDAwMDAwMDBjMDA2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjAwMDYwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDYwMDAwMDAwMDAwMDBjMDYwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjY2MDYwMDAwMDAwMGMwNjYwNjAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwMDYwMDAwMDAwMDAwMDBjMDY2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\",\n        \"displayName\": \"myAnim\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\",\n        \"water_sim.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759586316615,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace Shaders {\" line1=\"    const exampleShader: Shader = (frag, u) =&gt; {\" line2=\"        const x = frag.x / u.resolution.x;\" line3=\"        const y = frag.y / u.resolution.y;\" line4=\"\" line5=\"        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\" line6=\"        return v &gt; 0 ? 0.2 : 0.8;\" line7=\"    };\" line8=\"\" line9=\"    const plasmaShader: Shaders.Shader = (frag, u) =&gt; {\" line10=\"        // normalize coordinates\" line11=\"        const nx = frag.x / u.resolution.x;\" line12=\"        const ny = frag.y / u.resolution.y;\" line13=\"\" line14=\"        // combine multiple sine waves\" line15=\"        const w =\" line16=\"            Math.sin(nx * 10 + u.time) +\" line17=\"            Math.sin((ny * 10) + u.time * 1.3) +\" line18=\"            Math.sin((nx + ny) * 10 + u.time * 0.7);\" line19=\"\" line20=\"        // normalize to 0..1\" line21=\"        const normalized = (w + 3) / 6;\" line22=\"\" line23=\"        // map to grayscale shade (1–15)\" line24=\"        return normalized;\" line25=\"    };\" line26=\"\" line27=\"    const rippleShader: Shaders.Shader = (frag, u) =&gt; {\" line28=\"        const cx = frag.x - u.resolution.x / 2;\" line29=\"        const cy = frag.y - u.resolution.y / 2;\" line30=\"        const dist = Math.sqrt(cx * cx + cy * cy);\" line31=\"\" line32=\"        const a = Math.sin(dist * 0.1 - u.time * 2);\" line33=\"        const normalized2 = (a + 1) / 2;\" line34=\"\" line35=\"        return normalized2;\" line36=\"    };\" line37=\"\" line38=\"    const tunnelShader: Shaders.Shader = (frag, u) =&gt; {\" line39=\"        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\" line40=\"        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\" line41=\"\" line42=\"        const angle = Math.atan2(ny2, nx2);\" line43=\"        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\" line44=\"\" line45=\"        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\" line46=\"        return (b + 1) / 2;\" line47=\"    };\" line48=\"\" line49=\"    const checkerShader: Shaders.Shader = (frag, u) =&gt; {\" line50=\"        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\" line51=\"\" line52=\"        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\" line53=\"        return c ? 1.0 : 0.0;\" line54=\"    };\" line55=\"\" line56=\"    const circlesShader: Shaders.Shader = (frag, u) =&gt; {\" line57=\"        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\" line58=\"        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\" line59=\"\" line60=\"        const dx = frag.x - cx2;\" line61=\"        const dy = frag.y - cy2;\" line62=\"        const dist3 = Math.sqrt(dx * dx + dy * dy);\" line63=\"\" line64=\"        const d = Math.sin(dist3 * 0.2 - u.time * 2);\" line65=\"        return (d + 1) / 2;\" line66=\"    };\" line67=\"\" line68=\"    const marbleShader: Shaders.Shader = (frag, u) =&gt; {\" line69=\"        const nx3 = frag.x / u.resolution.x;\" line70=\"        const ny3 = frag.y / u.resolution.y;\" line71=\"\" line72=\"        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\" line73=\"        return (e + 1) / 2;\" line74=\"    };\" line75=\"\" line76=\"    const marbleWithWobble: Shaders.Shader = (frag, u) =&gt; {\" line77=\"        // normalized UVs 0..1\" line78=\"        let uvx = frag.x / u.resolution.x;\" line79=\"        let uvy = frag.y / u.resolution.y;\" line80=\"\" line81=\"        // warp Y coordinate\" line82=\"        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\" line83=\"\" line84=\"        // base marble pattern\" line85=\"        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\" line86=\"\" line87=\"        // GLSL does (v + 1)/2 to map -1..1 → 0..1\" line88=\"        return (f + 1.0) * 0.5;\" line89=\"    };\" line90=\"\" line91=\"    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\" line92=\"        // center coords\" line93=\"        const cx3 = frag.x - u.resolution.x / 2;\" line94=\"        const cy3 = frag.y - u.resolution.y / 2;\" line95=\"        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\" line96=\"\" line97=\"        // ripple parameters\" line98=\"        const freq = 0.1;     // wave spacing\" line99=\"        const speed = 4.0;    // animation speed\" line100=\"        const baseAmp = 0.05; // base amplitude\" line101=\"\" line102=\"        // damping: amplitude decays with distance\" line103=\"        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\" line104=\"\" line105=\"        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\" line106=\"\" line107=\"        // normalized UVs\" line108=\"        const uvx2 = frag.x / u.resolution.x;\" line109=\"        let uvy2 = frag.y / u.resolution.y;\" line110=\"\" line111=\"        // apply vertical ripple distortion\" line112=\"        uvy2 += offset;\" line113=\"\" line114=\"        return new Shaders.Vec2(uvx2, uvy2);\" line115=\"    }\" line116=\"\" line117=\"    const marbleWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line118=\"        // ripple-distorted UVs\" line119=\"        const uv = rippleWarp(frag, u);\" line120=\"\" line121=\"        // marble pattern\" line122=\"        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\" line123=\"\" line124=\"        // normalize to 0..1\" line125=\"        return (g + 1.0) * 0.5;\" line126=\"    };\" line127=\"\" line128=\"    // Checkerboard + radial ripple (UV warp) + brightness shimmer\" line129=\"    // Phases for warp and shimmer are split so you can tune alignment.\" line130=\"\" line131=\"    const checkerWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line132=\"        // --- 1. Distance from screen center ---\" line133=\"        const dx2 = frag.x - u.resolution.x / 2;\" line134=\"        const dy2 = frag.y - u.resolution.y / 2;\" line135=\"        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\" line136=\"\" line137=\"        // --- 2. Base ripple parameters ---\" line138=\"        const freq2 = 0.12;                   // ripple spacing\" line139=\"        const speed2 = 3.0;                   // animation speed\" line140=\"        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\" line141=\"        const phase = dist5 * freq2 - u.time * speed2;\" line142=\"\" line143=\"        // --- 3. Warp the UVs (position ripple) ---\" line144=\"        const uvx3 = frag.x / u.resolution.x;\" line145=\"        let uvy3 = frag.y / u.resolution.y;\" line146=\"\" line147=\"        const warpAmp = 0.05;\" line148=\"        const wave = Math.sin(phase);\" line149=\"        uvy3 += wave * warpAmp * damping2;\" line150=\"\" line151=\"        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\" line152=\"        const tiles = 10;\" line153=\"        const tx = Math.floor(uvx3 * tiles);\" line154=\"        const ty = Math.floor(uvy3 * tiles);\" line155=\"        const isWhite = ((tx + ty) &amp; 1) ? 1 : 0;\" line156=\"\" line157=\"        const baseBlack = 0.1;\" line158=\"        const baseWhite = 0.9;\" line159=\"        const base = isWhite ? baseWhite : baseBlack;\" line160=\"\" line161=\"        // --- 5. Recalculate radial distance *after* warp ---\" line162=\"        const dx22 = frag.x - u.resolution.x / 2;\" line163=\"        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\" line164=\"        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\" line165=\"\" line166=\"        // --- 6. Shimmer based on warped radial distance ---\" line167=\"        const shimmerPhase = distWarped * freq2 - u.time * speed2;\" line168=\"        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\" line169=\"\" line170=\"        // --- 7. Combine and clamp ---\" line171=\"        let L = base + shimmer;\" line172=\"        if (L &lt; 0) L = 0;\" line173=\"        if (L &gt; 1) L = 1;\" line174=\"\" line175=\"        return L;\" line176=\"    };\" line177=\"\" line178=\"    interface Ripple {\" line179=\"        origin: Shaders.Vec2;\" line180=\"        startTime: number;\" line181=\"\" line182=\"        // precomputed each frame\" line183=\"        age?: number;\" line184=\"        waveDist?: number;\" line185=\"    }\" line186=\"\" line187=\"    let ripples: Ripple[] = [];\" line188=\"\" line189=\"    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\" line190=\"        ripples.push({\" line191=\"            origin: new Shaders.Vec2(x, y),\" line192=\"            startTime: game.runtime() / 1000\" line193=\"        });\" line194=\"    })\" line195=\"\" line196=\"    game.onUpdate(() =&gt; {\" line197=\"        const now = game.runtime() / 1000;\" line198=\"        ripples = ripples.filter(r =&gt; now - r.startTime &lt; 5); // keep last 5s\" line199=\"\" line200=\"        // precompute per-ripple values once per frame\" line201=\"        for (const r of ripples) {\" line202=\"            r.age = now - r.startTime;\" line203=\"            r.waveDist = r.age * 40; // speed in px/sec\" line204=\"        }\" line205=\"    });\" line206=\"\" line207=\"    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\" line208=\"        const dx3 = frag.x - r.origin.x;\" line209=\"        const dy3 = frag.y - r.origin.y;\" line210=\"        const dist22 = dx3 * dx3 + dy3 * dy3;\" line211=\"\" line212=\"        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\" line213=\"        const diff = dist6 - (r.waveDist || 0);\" line214=\"\" line215=\"        // cull if pixel is far from wavefront\" line216=\"        if (Math.abs(diff) &gt; 40) return 0;\" line217=\"\" line218=\"        // simple triangular falloff instead of exp()\" line219=\"        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\" line220=\"\" line221=\"        // cheap oscillation (precompute freq/speed if needed)\" line222=\"        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\" line223=\"    }\" line224=\"\" line225=\"    const checkerWithRippleClick: Shaders.Shader = (frag, u) =&gt; {\" line226=\"        // --- Checkerboard base ---\" line227=\"        const uvx4 = frag.x / u.resolution.x;\" line228=\"        const uvy4 = frag.y / u.resolution.y;\" line229=\"        const scale2 = 10;\" line230=\"        const tx2 = Math.floor(uvx4 * scale2);\" line231=\"        const ty2 = Math.floor(uvy4 * scale2);\" line232=\"        const isWhite2 = ((tx2 + ty2) &amp; 1) ? 1 : 0;\" line233=\"        const base2 = isWhite2 ? 0.9 : 0.1;\" line234=\"\" line235=\"        // --- Accumulate ripple contributions ---\" line236=\"        let rippleSum = 0;\" line237=\"        for (let i = 0; i &lt; ripples.length &amp;&amp; i &lt; 4; i++) {\" line238=\"            rippleSum += rippleContribution(frag, ripples[i]);\" line239=\"        }\" line240=\"\" line241=\"        // combine (tune ripple strength)\" line242=\"        let L2 = base2 + rippleSum;\" line243=\"\" line244=\"        // clamp\" line245=\"        if (L2 &lt; 0) L2 = 0;\" line246=\"        if (L2 &gt; 1) L2 = 1;\" line247=\"\" line248=\"        return L2;\" line249=\"    };\" line250=\"\" line251=\"    // initDefaults()\" line252=\"    // setActiveProgram((uniforms, screen) =&gt; {\" line253=\"    //     runShader(checkerWithRipple, screen, uniforms);\" line254=\"    // })\" line255=\"}\" numlines=\"256\"></mutation></block></statement></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const w =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (w + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const a = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized2 = (a + 1) / 2;\n\n        return normalized2;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny2, nx2);\n        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\n        return (b + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return c ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx2;\n        const dy = frag.y - cy2;\n        const dist3 = Math.sqrt(dx * dx + dy * dy);\n\n        const d = Math.sin(dist3 * 0.2 - u.time * 2);\n        return (d + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx3 = frag.x / u.resolution.x;\n        const ny3 = frag.y / u.resolution.y;\n\n        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\n        return (e + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (f + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx3 = frag.x - u.resolution.x / 2;\n        const cy3 = frag.y - u.resolution.y / 2;\n        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\n\n        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx2 = frag.x / u.resolution.x;\n        let uvy2 = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy2 += offset;\n\n        return new Shaders.Vec2(uvx2, uvy2);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (g + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- 1. Distance from screen center ---\n        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = frag.y - u.resolution.y / 2;\n        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        // --- 2. Base ripple parameters ---\n        const freq2 = 0.12;                   // ripple spacing\n        const speed2 = 3.0;                   // animation speed\n        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\n        const phase = dist5 * freq2 - u.time * speed2;\n\n        // --- 3. Warp the UVs (position ripple) ---\n        const uvx3 = frag.x / u.resolution.x;\n        let uvy3 = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy3 += wave * warpAmp * damping2;\n\n        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\n        const tiles = 10;\n        const tx = Math.floor(uvx3 * tiles);\n        const ty = Math.floor(uvy3 * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- 5. Recalculate radial distance *after* warp ---\n        const dx22 = frag.x - u.resolution.x / 2;\n        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\n\n        // --- 6. Shimmer based on warped radial distance ---\n        const shimmerPhase = distWarped * freq2 - u.time * speed2;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\n\n        // --- 7. Combine and clamp ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    interface Ripple {\n        origin: Shaders.Vec2;\n        startTime: number;\n\n        // precomputed each frame\n        age?: number;\n        waveDist?: number;\n    }\n\n    let ripples: Ripple[] = [];\n\n    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n        ripples.push({\n            origin: new Shaders.Vec2(x, y),\n            startTime: game.runtime() / 1000\n        });\n    })\n\n    game.onUpdate(() => {\n        const now = game.runtime() / 1000;\n        ripples = ripples.filter(r => now - r.startTime < 5); // keep last 5s\n\n        // precompute per-ripple values once per frame\n        for (const r of ripples) {\n            r.age = now - r.startTime;\n            r.waveDist = r.age * 40; // speed in px/sec\n        }\n    });\n\n    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\n        const dx3 = frag.x - r.origin.x;\n        const dy3 = frag.y - r.origin.y;\n        const dist22 = dx3 * dx3 + dy3 * dy3;\n\n        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\n        const diff = dist6 - (r.waveDist || 0);\n\n        // cull if pixel is far from wavefront\n        if (Math.abs(diff) > 40) return 0;\n\n        // simple triangular falloff instead of exp()\n        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\n\n        // cheap oscillation (precompute freq/speed if needed)\n        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n    }\n\n    const checkerWithRippleClick: Shaders.Shader = (frag, u) => {\n        // --- Checkerboard base ---\n        const uvx4 = frag.x / u.resolution.x;\n        const uvy4 = frag.y / u.resolution.y;\n        const scale2 = 10;\n        const tx2 = Math.floor(uvx4 * scale2);\n        const ty2 = Math.floor(uvy4 * scale2);\n        const isWhite2 = ((tx2 + ty2) & 1) ? 1 : 0;\n        const base2 = isWhite2 ? 0.9 : 0.1;\n\n        // --- Accumulate ripple contributions ---\n        let rippleSum = 0;\n        for (let i = 0; i < ripples.length && i < 4; i++) {\n            rippleSum += rippleContribution(frag, ripples[i]);\n        }\n\n        // combine (tune ripple strength)\n        let L2 = base2 + rippleSum;\n\n        // clamp\n        if (L2 < 0) L2 = 0;\n        if (L2 > 1) L2 = 1;\n\n        return L2;\n    };\n\n    // initDefaults()\n    // setActiveProgram((uniforms, screen) => {\n    //     runShader(checkerWithRipple, screen, uniforms);\n    // })\n}\n","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","water_sim.ts":"namespace WaterSim {\n    export const GW = 60;\n    export const GH = 45;\n    const FP = 256;\n\n    // Damping\n    const DAMP_NUM = 230;\n    const DAMP_SHIFT = 8;\n\n    // Pre-allocate buffers as plain number[] with fixed size\n    const SIZE = GW * GH;\n    let A: number[] = [];\n    let B: number[] = [];\n    let C: number[] = [];\n\n    // Manual initialization (no `new Array`)\n    export function init() {\n        A = [];\n        B = [];\n        C = [];\n        for (let i = 0; i < SIZE; i++) {\n            A.push(0);\n            B.push(0);\n            C.push(0);\n        }\n    }\n\n    let prev: number[];\n    let cur: number[];\n    let nextB: number[];\n\n    export function reset() {\n        init();\n        prev = A;\n        cur = B;\n        nextB = C;\n    }\n\n    function idx(x: number, y: number) { return y * GW + x; }\n\n    // Splash at screen coords\n    export function splash(sx: number, sy: number, strength = 1, radiusPx = 10) {\n        const gx = Math.idiv(sx * GW, screen.width);\n        const gy = Math.idiv(sy * GH, screen.height);\n        const r = Math.max(1, Math.idiv(radiusPx * GW, screen.width));\n\n        const amp = (strength * FP) | 0;\n\n        for (let y = Math.max(1, gy - r); y <= Math.min(GH - 2, gy + r); y++) {\n            for (let x = Math.max(1, gx - r); x <= Math.min(GW - 2, gx + r); x++) {\n                const dx = x - gx;\n                const dy = y - gy;\n                const d2 = dx * dx + dy * dy;\n                if (d2 <= r * r) {\n                    cur[idx(x, y)] += amp;\n                }\n            }\n        }\n    }\n\n    export function step() {\n        for (let y = 1; y < GH - 1; y++) {\n            const yW = y * GW;\n            for (let x = 1; x < GW - 1; x++) {\n                const i = yW + x;\n                const sum = cur[i - 1] + cur[i + 1] + cur[i - GW] + cur[i + GW];\n                let n = (sum >> 1) - prev[i];\n                n = (n * DAMP_NUM) >> DAMP_SHIFT;\n                nextB[i] = n;\n            }\n        }\n        // rotate\n        const tmp = prev; prev = cur; cur = nextB; nextB = tmp;\n    }\n\n    export function sampleHeight(sx: number, sy: number): number {\n        const gx = sx * (GW - 1) / (screen.width - 1);\n        const gy = sy * (GH - 1) / (screen.height - 1);\n\n        const x0 = Math.max(0, Math.min(GW - 2, Math.floor(gx)));\n        const y0 = Math.max(0, Math.min(GH - 2, Math.floor(gy)));\n        const tx = gx - x0;\n        const ty = gy - y0;\n\n        const i00 = cur[idx(x0, y0)];\n        const i10 = cur[idx(x0 + 1, y0)];\n        const i01 = cur[idx(x0, y0 + 1)];\n        const i11 = cur[idx(x0 + 1, y0 + 1)];\n\n        const a = i00 * (1 - tx) + i10 * tx;\n        const b = i01 * (1 - tx) + i11 * tx;\n        const hFP = a * (1 - ty) + b * ty;\n\n        return (hFP / FP) / 2;\n    }\n}\n\nWaterSim.reset();\n\nlet mouse = new Shaders.Vec2(80, 60)\nlet rippleOrigin = new Shaders.Vec2(80, 60)\n// let boat = sprites.create(assets.image`boat0`)\n\nbrowserEvents.onMouseMove(function(x: number, y: number) {\n    mouse.x = x\n    mouse.y = y\n    if (browserEvents.MouseLeft.isPressed()) {\n        WaterSim.splash(rippleOrigin.x, rippleOrigin.y, 1.0, 4);\n    }\n})\n\ngame.onUpdate(function () {\n    WaterSim.step();\n    const move = mouse.sub(rippleOrigin).normalize().mul(5)\n    rippleOrigin = rippleOrigin.add(move)\n\n});\n\nconst checkerWaterShader: Shaders.Shader = (frag, u) => {\n    const h = WaterSim.sampleHeight(frag.x, frag.y);\n\n    const uvx = frag.x / u.resolution.x;\n    let uvy = frag.y / u.resolution.y + h * 0.15;\n\n    const tiles = 10;\n    const tx = Math.floor(uvx * tiles);\n    const ty = Math.floor(uvy * tiles);\n    const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n    let L = isWhite ? 0.9 : 0.1;\n    L += h * 0.5;\n\n    if (L < 0) L = 0;\n    if (L > 1) L = 1;\n\n    return L;\n};\n\nShaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})","images.g.jres":"{\n    \"image3\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAODuDgAAAAAArursAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACurs4AAAAAAK6uzgAAAAAArq7OAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAOCq7gAAAAAAAO4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-90\"\n    },\n    \"image4\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAADuDgAAAAAA4KruAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK6uzgAAAAAArq7OAAAAAACurs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK7q7AAAAAAA4O4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-270\"\n    },\n    \"image5\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODOAAAAAAAAruoMAAAAAOCqqs4AAAAArqqq6gwAAOCqqqrqDAAAruquqs4MAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAK6qqs4MAAAArqrqzAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-45\"\n    },\n    \"image6\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqzAAAAACuqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgwAAOCqqqrqDAAAAK6qquoMAAAA4KqqzgAAAAAAruoMAAAAAADgzgAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-315\"\n    },\n    \"image7\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqDAAAAOCqquoMAAAArqqq6gwAAOCqqqrqDAAAruquqs4AAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAOCqqs4MAAAAAK7qzAAAAAAA4M4MAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-225\"\n    },\n    \"image8\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAADgzgwAAAAAAK7qzAAAAADgqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgAAAOCqqqrqDAAAAK6qquoMAAAA4Kqq6gwAAAAArqrqDAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-135\"\n    },\n    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gDgqqqqqqrqAOCqquququoA4Kqq6q6q6gDgqqqqqqrqAACuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat0\"\n    },\n    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gAArqqqqqqqDgCuququqqoOAK6q6q6qqg4ArqqqqqqqDgCuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat180\"\n    },\n    \"anim1\": {\n        \"namespace\": \"myAnimations\",\n        \"id\": \"anim1\",\n        \"mimeType\": \"application/mkcd-animation\",\n        \"data\": \"NTAwMDEwMDAxMDAwMDUwMDAwMDAwMDYwNjYwMDAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjY2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDA2NjAwNjAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwNjAwMDAwMDAwMDAwMGMwNjAwMDAwMDAwMDAwMDBjMDA2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjAwMDYwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDYwMDAwMDAwMDAwMDBjMDYwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjY2MDYwMDAwMDAwMGMwNjYwNjAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwMDYwMDAwMDAwMDAwMDBjMDY2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\",\n        \"displayName\": \"myAnim\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\",\n        \"water_sim.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759589939358,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace Shaders {\" line1=\"    const exampleShader: Shader = (frag, u) =&gt; {\" line2=\"        const x = frag.x / u.resolution.x;\" line3=\"        const y = frag.y / u.resolution.y;\" line4=\"\" line5=\"        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\" line6=\"        return v &gt; 0 ? 0.2 : 0.8;\" line7=\"    };\" line8=\"\" line9=\"    const plasmaShader: Shaders.Shader = (frag, u) =&gt; {\" line10=\"        // normalize coordinates\" line11=\"        const nx = frag.x / u.resolution.x;\" line12=\"        const ny = frag.y / u.resolution.y;\" line13=\"\" line14=\"        // combine multiple sine waves\" line15=\"        const w =\" line16=\"            Math.sin(nx * 10 + u.time) +\" line17=\"            Math.sin((ny * 10) + u.time * 1.3) +\" line18=\"            Math.sin((nx + ny) * 10 + u.time * 0.7);\" line19=\"\" line20=\"        // normalize to 0..1\" line21=\"        const normalized = (w + 3) / 6;\" line22=\"\" line23=\"        // map to grayscale shade (1–15)\" line24=\"        return normalized;\" line25=\"    };\" line26=\"\" line27=\"    const rippleShader: Shaders.Shader = (frag, u) =&gt; {\" line28=\"        const cx = frag.x - u.resolution.x / 2;\" line29=\"        const cy = frag.y - u.resolution.y / 2;\" line30=\"        const dist = Math.sqrt(cx * cx + cy * cy);\" line31=\"\" line32=\"        const a = Math.sin(dist * 0.1 - u.time * 2);\" line33=\"        const normalized2 = (a + 1) / 2;\" line34=\"\" line35=\"        return normalized2;\" line36=\"    };\" line37=\"\" line38=\"    const tunnelShader: Shaders.Shader = (frag, u) =&gt; {\" line39=\"        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\" line40=\"        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\" line41=\"\" line42=\"        const angle = Math.atan2(ny2, nx2);\" line43=\"        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\" line44=\"\" line45=\"        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\" line46=\"        return (b + 1) / 2;\" line47=\"    };\" line48=\"\" line49=\"    const checkerShader: Shaders.Shader = (frag, u) =&gt; {\" line50=\"        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\" line51=\"\" line52=\"        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\" line53=\"        return c ? 1.0 : 0.0;\" line54=\"    };\" line55=\"\" line56=\"    const circlesShader: Shaders.Shader = (frag, u) =&gt; {\" line57=\"        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\" line58=\"        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\" line59=\"\" line60=\"        const dx = frag.x - cx2;\" line61=\"        const dy = frag.y - cy2;\" line62=\"        const dist3 = Math.sqrt(dx * dx + dy * dy);\" line63=\"\" line64=\"        const d = Math.sin(dist3 * 0.2 - u.time * 2);\" line65=\"        return (d + 1) / 2;\" line66=\"    };\" line67=\"\" line68=\"    const marbleShader: Shaders.Shader = (frag, u) =&gt; {\" line69=\"        const nx3 = frag.x / u.resolution.x;\" line70=\"        const ny3 = frag.y / u.resolution.y;\" line71=\"\" line72=\"        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\" line73=\"        return (e + 1) / 2;\" line74=\"    };\" line75=\"\" line76=\"    const marbleWithWobble: Shaders.Shader = (frag, u) =&gt; {\" line77=\"        // normalized UVs 0..1\" line78=\"        let uvx = frag.x / u.resolution.x;\" line79=\"        let uvy = frag.y / u.resolution.y;\" line80=\"\" line81=\"        // warp Y coordinate\" line82=\"        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\" line83=\"\" line84=\"        // base marble pattern\" line85=\"        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\" line86=\"\" line87=\"        // GLSL does (v + 1)/2 to map -1..1 → 0..1\" line88=\"        return (f + 1.0) * 0.5;\" line89=\"    };\" line90=\"\" line91=\"    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\" line92=\"        // center coords\" line93=\"        const cx3 = frag.x - u.resolution.x / 2;\" line94=\"        const cy3 = frag.y - u.resolution.y / 2;\" line95=\"        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\" line96=\"\" line97=\"        // ripple parameters\" line98=\"        const freq = 0.1;     // wave spacing\" line99=\"        const speed = 4.0;    // animation speed\" line100=\"        const baseAmp = 0.05; // base amplitude\" line101=\"\" line102=\"        // damping: amplitude decays with distance\" line103=\"        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\" line104=\"\" line105=\"        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\" line106=\"\" line107=\"        // normalized UVs\" line108=\"        const uvx2 = frag.x / u.resolution.x;\" line109=\"        let uvy2 = frag.y / u.resolution.y;\" line110=\"\" line111=\"        // apply vertical ripple distortion\" line112=\"        uvy2 += offset;\" line113=\"\" line114=\"        return new Shaders.Vec2(uvx2, uvy2);\" line115=\"    }\" line116=\"\" line117=\"    const marbleWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line118=\"        // ripple-distorted UVs\" line119=\"        const uv = rippleWarp(frag, u);\" line120=\"\" line121=\"        // marble pattern\" line122=\"        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\" line123=\"\" line124=\"        // normalize to 0..1\" line125=\"        return (g + 1.0) * 0.5;\" line126=\"    };\" line127=\"\" line128=\"    // Checkerboard + radial ripple (UV warp) + brightness shimmer\" line129=\"    // Phases for warp and shimmer are split so you can tune alignment.\" line130=\"\" line131=\"    const checkerWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line132=\"        // --- 1. Distance from screen center ---\" line133=\"        const dx2 = frag.x - u.resolution.x / 2;\" line134=\"        const dy2 = frag.y - u.resolution.y / 2;\" line135=\"        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\" line136=\"\" line137=\"        // --- 2. Base ripple parameters ---\" line138=\"        const freq2 = 0.12;                   // ripple spacing\" line139=\"        const speed2 = 3.0;                   // animation speed\" line140=\"        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\" line141=\"        const phase = dist5 * freq2 - u.time * speed2;\" line142=\"\" line143=\"        // --- 3. Warp the UVs (position ripple) ---\" line144=\"        const uvx3 = frag.x / u.resolution.x;\" line145=\"        let uvy3 = frag.y / u.resolution.y;\" line146=\"\" line147=\"        const warpAmp = 0.05;\" line148=\"        const wave = Math.sin(phase);\" line149=\"        uvy3 += wave * warpAmp * damping2;\" line150=\"\" line151=\"        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\" line152=\"        const tiles = 10;\" line153=\"        const tx = Math.floor(uvx3 * tiles);\" line154=\"        const ty = Math.floor(uvy3 * tiles);\" line155=\"        const isWhite = ((tx + ty) &amp; 1) ? 1 : 0;\" line156=\"\" line157=\"        const baseBlack = 0.1;\" line158=\"        const baseWhite = 0.9;\" line159=\"        const base = isWhite ? baseWhite : baseBlack;\" line160=\"\" line161=\"        // --- 5. Recalculate radial distance *after* warp ---\" line162=\"        const dx22 = frag.x - u.resolution.x / 2;\" line163=\"        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\" line164=\"        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\" line165=\"\" line166=\"        // --- 6. Shimmer based on warped radial distance ---\" line167=\"        const shimmerPhase = distWarped * freq2 - u.time * speed2;\" line168=\"        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\" line169=\"\" line170=\"        // --- 7. Combine and clamp ---\" line171=\"        let L = base + shimmer;\" line172=\"        if (L &lt; 0) L = 0;\" line173=\"        if (L &gt; 1) L = 1;\" line174=\"\" line175=\"        return L;\" line176=\"    };\" line177=\"\" line178=\"    interface Ripple {\" line179=\"        origin: Shaders.Vec2;\" line180=\"        startTime: number;\" line181=\"\" line182=\"        // precomputed each frame\" line183=\"        age?: number;\" line184=\"        waveDist?: number;\" line185=\"    }\" line186=\"\" line187=\"    let ripples: Ripple[] = [];\" line188=\"\" line189=\"    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\" line190=\"        ripples.push({\" line191=\"            origin: new Shaders.Vec2(x, y),\" line192=\"            startTime: game.runtime() / 1000\" line193=\"        });\" line194=\"    })\" line195=\"\" line196=\"    game.onUpdate(() =&gt; {\" line197=\"        const now = game.runtime() / 1000;\" line198=\"        ripples = ripples.filter(r =&gt; now - r.startTime &lt; 5); // keep last 5s\" line199=\"\" line200=\"        // precompute per-ripple values once per frame\" line201=\"        for (const r of ripples) {\" line202=\"            r.age = now - r.startTime;\" line203=\"            r.waveDist = r.age * 40; // speed in px/sec\" line204=\"        }\" line205=\"    });\" line206=\"\" line207=\"    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\" line208=\"        const dx3 = frag.x - r.origin.x;\" line209=\"        const dy3 = frag.y - r.origin.y;\" line210=\"        const dist22 = dx3 * dx3 + dy3 * dy3;\" line211=\"\" line212=\"        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\" line213=\"        const diff = dist6 - (r.waveDist || 0);\" line214=\"\" line215=\"        // cull if pixel is far from wavefront\" line216=\"        if (Math.abs(diff) &gt; 40) return 0;\" line217=\"\" line218=\"        // simple triangular falloff instead of exp()\" line219=\"        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\" line220=\"\" line221=\"        // cheap oscillation (precompute freq/speed if needed)\" line222=\"        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\" line223=\"    }\" line224=\"\" line225=\"    const checkerWithRippleClick: Shaders.Shader = (frag, u) =&gt; {\" line226=\"        // --- Checkerboard base ---\" line227=\"        const uvx4 = frag.x / u.resolution.x;\" line228=\"        const uvy4 = frag.y / u.resolution.y;\" line229=\"        const scale2 = 10;\" line230=\"        const tx2 = Math.floor(uvx4 * scale2);\" line231=\"        const ty2 = Math.floor(uvy4 * scale2);\" line232=\"        const isWhite2 = ((tx2 + ty2) &amp; 1) ? 1 : 0;\" line233=\"        const base2 = isWhite2 ? 0.9 : 0.1;\" line234=\"\" line235=\"        // --- Accumulate ripple contributions ---\" line236=\"        let rippleSum = 0;\" line237=\"        for (let i = 0; i &lt; ripples.length &amp;&amp; i &lt; 4; i++) {\" line238=\"            rippleSum += rippleContribution(frag, ripples[i]);\" line239=\"        }\" line240=\"\" line241=\"        // combine (tune ripple strength)\" line242=\"        let L2 = base2 + rippleSum;\" line243=\"\" line244=\"        // clamp\" line245=\"        if (L2 &lt; 0) L2 = 0;\" line246=\"        if (L2 &gt; 1) L2 = 1;\" line247=\"\" line248=\"        return L2;\" line249=\"    };\" line250=\"\" line251=\"    // initDefaults()\" line252=\"    // setActiveProgram((uniforms, screen) =&gt; {\" line253=\"    //     runShader(checkerWithRipple, screen, uniforms);\" line254=\"    // })\" line255=\"}\" numlines=\"256\"></mutation></block></statement></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const w =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (w + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const a = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized2 = (a + 1) / 2;\n\n        return normalized2;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny2, nx2);\n        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\n        return (b + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return c ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx2;\n        const dy = frag.y - cy2;\n        const dist3 = Math.sqrt(dx * dx + dy * dy);\n\n        const d = Math.sin(dist3 * 0.2 - u.time * 2);\n        return (d + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx3 = frag.x / u.resolution.x;\n        const ny3 = frag.y / u.resolution.y;\n\n        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\n        return (e + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (f + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx3 = frag.x - u.resolution.x / 2;\n        const cy3 = frag.y - u.resolution.y / 2;\n        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\n\n        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx2 = frag.x / u.resolution.x;\n        let uvy2 = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy2 += offset;\n\n        return new Shaders.Vec2(uvx2, uvy2);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (g + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- 1. Distance from screen center ---\n        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = frag.y - u.resolution.y / 2;\n        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        // --- 2. Base ripple parameters ---\n        const freq2 = 0.12;                   // ripple spacing\n        const speed2 = 3.0;                   // animation speed\n        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\n        const phase = dist5 * freq2 - u.time * speed2;\n\n        // --- 3. Warp the UVs (position ripple) ---\n        const uvx3 = frag.x / u.resolution.x;\n        let uvy3 = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy3 += wave * warpAmp * damping2;\n\n        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\n        const tiles = 10;\n        const tx = Math.floor(uvx3 * tiles);\n        const ty = Math.floor(uvy3 * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- 5. Recalculate radial distance *after* warp ---\n        const dx22 = frag.x - u.resolution.x / 2;\n        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\n\n        // --- 6. Shimmer based on warped radial distance ---\n        const shimmerPhase = distWarped * freq2 - u.time * speed2;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\n\n        // --- 7. Combine and clamp ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    interface Ripple {\n        origin: Shaders.Vec2;\n        startTime: number;\n\n        // precomputed each frame\n        age?: number;\n        waveDist?: number;\n    }\n\n    let ripples: Ripple[] = [];\n\n    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n        ripples.push({\n            origin: new Shaders.Vec2(x, y),\n            startTime: game.runtime() / 1000\n        });\n    })\n\n    game.onUpdate(() => {\n        const now = game.runtime() / 1000;\n        ripples = ripples.filter(r => now - r.startTime < 5); // keep last 5s\n\n        // precompute per-ripple values once per frame\n        for (const r of ripples) {\n            r.age = now - r.startTime;\n            r.waveDist = r.age * 40; // speed in px/sec\n        }\n    });\n\n    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\n        const dx3 = frag.x - r.origin.x;\n        const dy3 = frag.y - r.origin.y;\n        const dist22 = dx3 * dx3 + dy3 * dy3;\n\n        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\n        const diff = dist6 - (r.waveDist || 0);\n\n        // cull if pixel is far from wavefront\n        if (Math.abs(diff) > 40) return 0;\n\n        // simple triangular falloff instead of exp()\n        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\n\n        // cheap oscillation (precompute freq/speed if needed)\n        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n    }\n\n    const checkerWithRippleClick: Shaders.Shader = (frag, u) => {\n        // --- Checkerboard base ---\n        const uvx4 = frag.x / u.resolution.x;\n        const uvy4 = frag.y / u.resolution.y;\n        const scale2 = 10;\n        const tx2 = Math.floor(uvx4 * scale2);\n        const ty2 = Math.floor(uvy4 * scale2);\n        const isWhite2 = ((tx2 + ty2) & 1) ? 1 : 0;\n        const base2 = isWhite2 ? 0.9 : 0.1;\n\n        // --- Accumulate ripple contributions ---\n        let rippleSum = 0;\n        for (let i = 0; i < ripples.length && i < 4; i++) {\n            rippleSum += rippleContribution(frag, ripples[i]);\n        }\n\n        // combine (tune ripple strength)\n        let L2 = base2 + rippleSum;\n\n        // clamp\n        if (L2 < 0) L2 = 0;\n        if (L2 > 1) L2 = 1;\n\n        return L2;\n    };\n\n    // initDefaults()\n    // setActiveProgram((uniforms, screen) => {\n    //     runShader(checkerWithRipple, screen, uniforms);\n    // })\n}\n","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","water_sim.ts":"namespace WaterSim {\n    export const GW = 60;\n    export const GH = 45;\n    const FP = 256;\n\n    // Damping\n    const DAMP_NUM = 230;\n    const DAMP_SHIFT = 8;\n\n    // Pre-allocate buffers as plain number[] with fixed size\n    const SIZE = GW * GH;\n    let A: number[] = [];\n    let B: number[] = [];\n    let C: number[] = [];\n\n    // Manual initialization (no `new Array`)\n    export function init() {\n        A = [];\n        B = [];\n        C = [];\n        for (let i = 0; i < SIZE; i++) {\n            A.push(0);\n            B.push(0);\n            C.push(0);\n        }\n    }\n\n    let prev: number[];\n    let cur: number[];\n    let nextB: number[];\n\n    export function reset() {\n        init();\n        prev = A;\n        cur = B;\n        nextB = C;\n    }\n\n    function idx(x: number, y: number) { return y * GW + x; }\n\n    // Splash at screen coords\n    export function splash(sx: number, sy: number, strength = 1, radiusPx = 10) {\n        const gx = Math.idiv(sx * GW, screen.width);\n        const gy = Math.idiv(sy * GH, screen.height);\n        const r = Math.max(1, Math.idiv(radiusPx * GW, screen.width));\n\n        const amp = (strength * FP) | 0;\n\n        for (let y = Math.max(1, gy - r); y <= Math.min(GH - 2, gy + r); y++) {\n            for (let x = Math.max(1, gx - r); x <= Math.min(GW - 2, gx + r); x++) {\n                const dx = x - gx;\n                const dy = y - gy;\n                const d2 = dx * dx + dy * dy;\n                if (d2 <= r * r) {\n                    cur[idx(x, y)] += amp;\n                }\n            }\n        }\n    }\n\n    export function step() {\n        for (let y = 1; y < GH - 1; y++) {\n            const yW = y * GW;\n            for (let x = 1; x < GW - 1; x++) {\n                const i = yW + x;\n                const sum = cur[i - 1] + cur[i + 1] + cur[i - GW] + cur[i + GW];\n                let n = (sum >> 1) - prev[i];\n                n = (n * DAMP_NUM) >> DAMP_SHIFT;\n                nextB[i] = n;\n            }\n        }\n        // rotate\n        const tmp = prev; prev = cur; cur = nextB; nextB = tmp;\n    }\n\n    export function sampleHeight(sx: number, sy: number): number {\n        const gx = sx * (GW - 1) / (screen.width - 1);\n        const gy = sy * (GH - 1) / (screen.height - 1);\n\n        const x0 = Math.max(0, Math.min(GW - 2, Math.floor(gx)));\n        const y0 = Math.max(0, Math.min(GH - 2, Math.floor(gy)));\n        const tx = gx - x0;\n        const ty = gy - y0;\n\n        const i00 = cur[idx(x0, y0)];\n        const i10 = cur[idx(x0 + 1, y0)];\n        const i01 = cur[idx(x0, y0 + 1)];\n        const i11 = cur[idx(x0 + 1, y0 + 1)];\n\n        const a = i00 * (1 - tx) + i10 * tx;\n        const b = i01 * (1 - tx) + i11 * tx;\n        const hFP = a * (1 - ty) + b * ty;\n\n        return (hFP / FP) / 2;\n    }\n}\n\nWaterSim.reset();\n\nlet mouse = new Shaders.Vec2(80, 60)\nlet rippleOrigin = new Shaders.Vec2(80, 60)\n// let boat = sprites.create(assets.image`boat0`)\n\nbrowserEvents.onMouseMove(function(x: number, y: number) {\n    mouse.x = x\n    mouse.y = y\n    if (browserEvents.MouseLeft.isPressed()) {\n        WaterSim.splash(rippleOrigin.x, rippleOrigin.y, 1.0, 4);\n    }\n})\n\ngame.onUpdate(function () {\n    WaterSim.step();\n    const move = mouse.sub(rippleOrigin).normalize().mul(5)\n    rippleOrigin = rippleOrigin.add(move)\n\n});\n\nconst checkerWaterShader: Shaders.Shader = (frag, u) => {\n    const h = WaterSim.sampleHeight(frag.x, frag.y);\n\n    const uvx = frag.x / u.resolution.x;\n    let uvy = frag.y / u.resolution.y + h * 0.15;\n\n    const tiles = 10;\n    const tx = Math.floor(uvx * tiles);\n    const ty = Math.floor(uvy * tiles);\n    const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n    let L = isWhite ? 0.9 : 0.1;\n    L += h * 0.5;\n\n    if (L < 0) L = 0;\n    if (L > 1) L = 1;\n\n    return L;\n};\n\nShaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})","images.g.jres":"{\n    \"image3\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAODuDgAAAAAArursAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACurs4AAAAAAK6uzgAAAAAArq7OAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAOCq7gAAAAAAAO4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-90\"\n    },\n    \"image4\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAADuDgAAAAAA4KruAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK6uzgAAAAAArq7OAAAAAACurs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK7q7AAAAAAA4O4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-270\"\n    },\n    \"image5\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODOAAAAAAAAruoMAAAAAOCqqs4AAAAArqqq6gwAAOCqqqrqDAAAruquqs4MAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAK6qqs4MAAAArqrqzAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-45\"\n    },\n    \"image6\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqzAAAAACuqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgwAAOCqqqrqDAAAAK6qquoMAAAA4KqqzgAAAAAAruoMAAAAAADgzgAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-315\"\n    },\n    \"image7\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqDAAAAOCqquoMAAAArqqq6gwAAOCqqqrqDAAAruquqs4AAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAOCqqs4MAAAAAK7qzAAAAAAA4M4MAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-225\"\n    },\n    \"image8\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAADgzgwAAAAAAK7qzAAAAADgqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgAAAOCqqqrqDAAAAK6qquoMAAAA4Kqq6gwAAAAArqrqDAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-135\"\n    },\n    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gDgqqqqqqrqAOCqquququoA4Kqq6q6q6gDgqqqqqqrqAACuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat0\"\n    },\n    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7g4AAK6qqqqq6gAArqqqqqqqDgCuququqqoOAK6q6q6qqg4ArqqqqqqqDgCuqqqqquoAAODu7u7uDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat180\"\n    },\n    \"anim1\": {\n        \"namespace\": \"myAnimations\",\n        \"id\": \"anim1\",\n        \"mimeType\": \"application/mkcd-animation\",\n        \"data\": \"NTAwMDEwMDAxMDAwMDUwMDAwMDAwMDYwNjYwMDAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjY2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDA2NjAwNjAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwNjAwMDAwMDAwMDAwMGMwNjAwMDAwMDAwMDAwMDBjMDA2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjAwMDYwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDYwMDAwMDAwMDAwMDBjMDYwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjY2MDYwMDAwMDAwMGMwNjYwNjAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwMDYwMDAwMDAwMDAwMDBjMDY2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\",\n        \"displayName\": \"myAnim\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\",\n        \"water_sim.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}},{"timestamp":1759591851418,"editorVersion":"2.0.59","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"typescript_statement\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace Shaders {\" line1=\"    const exampleShader: Shader = (frag, u) =&gt; {\" line2=\"        const x = frag.x / u.resolution.x;\" line3=\"        const y = frag.y / u.resolution.y;\" line4=\"\" line5=\"        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\" line6=\"        return v &gt; 0 ? 0.2 : 0.8;\" line7=\"    };\" line8=\"\" line9=\"    const plasmaShader: Shaders.Shader = (frag, u) =&gt; {\" line10=\"        // normalize coordinates\" line11=\"        const nx = frag.x / u.resolution.x;\" line12=\"        const ny = frag.y / u.resolution.y;\" line13=\"\" line14=\"        // combine multiple sine waves\" line15=\"        const w =\" line16=\"            Math.sin(nx * 10 + u.time) +\" line17=\"            Math.sin((ny * 10) + u.time * 1.3) +\" line18=\"            Math.sin((nx + ny) * 10 + u.time * 0.7);\" line19=\"\" line20=\"        // normalize to 0..1\" line21=\"        const normalized = (w + 3) / 6;\" line22=\"\" line23=\"        // map to grayscale shade (1–15)\" line24=\"        return normalized;\" line25=\"    };\" line26=\"\" line27=\"    const rippleShader: Shaders.Shader = (frag, u) =&gt; {\" line28=\"        const cx = frag.x - u.resolution.x / 2;\" line29=\"        const cy = frag.y - u.resolution.y / 2;\" line30=\"        const dist = Math.sqrt(cx * cx + cy * cy);\" line31=\"\" line32=\"        const a = Math.sin(dist * 0.1 - u.time * 2);\" line33=\"        const normalized2 = (a + 1) / 2;\" line34=\"\" line35=\"        return normalized2;\" line36=\"    };\" line37=\"\" line38=\"    const tunnelShader: Shaders.Shader = (frag, u) =&gt; {\" line39=\"        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\" line40=\"        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\" line41=\"\" line42=\"        const angle = Math.atan2(ny2, nx2);\" line43=\"        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\" line44=\"\" line45=\"        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\" line46=\"        return (b + 1) / 2;\" line47=\"    };\" line48=\"\" line49=\"    const checkerShader: Shaders.Shader = (frag, u) =&gt; {\" line50=\"        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\" line51=\"\" line52=\"        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\" line53=\"        return c ? 1.0 : 0.0;\" line54=\"    };\" line55=\"\" line56=\"    const circlesShader: Shaders.Shader = (frag, u) =&gt; {\" line57=\"        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\" line58=\"        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\" line59=\"\" line60=\"        const dx = frag.x - cx2;\" line61=\"        const dy = frag.y - cy2;\" line62=\"        const dist3 = Math.sqrt(dx * dx + dy * dy);\" line63=\"\" line64=\"        const d = Math.sin(dist3 * 0.2 - u.time * 2);\" line65=\"        return (d + 1) / 2;\" line66=\"    };\" line67=\"\" line68=\"    const marbleShader: Shaders.Shader = (frag, u) =&gt; {\" line69=\"        const nx3 = frag.x / u.resolution.x;\" line70=\"        const ny3 = frag.y / u.resolution.y;\" line71=\"\" line72=\"        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\" line73=\"        return (e + 1) / 2;\" line74=\"    };\" line75=\"\" line76=\"    const marbleWithWobble: Shaders.Shader = (frag, u) =&gt; {\" line77=\"        // normalized UVs 0..1\" line78=\"        let uvx = frag.x / u.resolution.x;\" line79=\"        let uvy = frag.y / u.resolution.y;\" line80=\"\" line81=\"        // warp Y coordinate\" line82=\"        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\" line83=\"\" line84=\"        // base marble pattern\" line85=\"        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\" line86=\"\" line87=\"        // GLSL does (v + 1)/2 to map -1..1 → 0..1\" line88=\"        return (f + 1.0) * 0.5;\" line89=\"    };\" line90=\"\" line91=\"    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\" line92=\"        // center coords\" line93=\"        const cx3 = frag.x - u.resolution.x / 2;\" line94=\"        const cy3 = frag.y - u.resolution.y / 2;\" line95=\"        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\" line96=\"\" line97=\"        // ripple parameters\" line98=\"        const freq = 0.1;     // wave spacing\" line99=\"        const speed = 4.0;    // animation speed\" line100=\"        const baseAmp = 0.05; // base amplitude\" line101=\"\" line102=\"        // damping: amplitude decays with distance\" line103=\"        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\" line104=\"\" line105=\"        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\" line106=\"\" line107=\"        // normalized UVs\" line108=\"        const uvx2 = frag.x / u.resolution.x;\" line109=\"        let uvy2 = frag.y / u.resolution.y;\" line110=\"\" line111=\"        // apply vertical ripple distortion\" line112=\"        uvy2 += offset;\" line113=\"\" line114=\"        return new Shaders.Vec2(uvx2, uvy2);\" line115=\"    }\" line116=\"\" line117=\"    const marbleWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line118=\"        // ripple-distorted UVs\" line119=\"        const uv = rippleWarp(frag, u);\" line120=\"\" line121=\"        // marble pattern\" line122=\"        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\" line123=\"\" line124=\"        // normalize to 0..1\" line125=\"        return (g + 1.0) * 0.5;\" line126=\"    };\" line127=\"\" line128=\"    // Checkerboard + radial ripple (UV warp) + brightness shimmer\" line129=\"    // Phases for warp and shimmer are split so you can tune alignment.\" line130=\"\" line131=\"    const checkerWithRipple: Shaders.Shader = (frag, u) =&gt; {\" line132=\"        // --- 1. Distance from screen center ---\" line133=\"        const dx2 = frag.x - u.resolution.x / 2;\" line134=\"        const dy2 = frag.y - u.resolution.y / 2;\" line135=\"        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\" line136=\"\" line137=\"        // --- 2. Base ripple parameters ---\" line138=\"        const freq2 = 0.12;                   // ripple spacing\" line139=\"        const speed2 = 3.0;                   // animation speed\" line140=\"        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\" line141=\"        const phase = dist5 * freq2 - u.time * speed2;\" line142=\"\" line143=\"        // --- 3. Warp the UVs (position ripple) ---\" line144=\"        const uvx3 = frag.x / u.resolution.x;\" line145=\"        let uvy3 = frag.y / u.resolution.y;\" line146=\"\" line147=\"        const warpAmp = 0.05;\" line148=\"        const wave = Math.sin(phase);\" line149=\"        uvy3 += wave * warpAmp * damping2;\" line150=\"\" line151=\"        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\" line152=\"        const tiles = 10;\" line153=\"        const tx = Math.floor(uvx3 * tiles);\" line154=\"        const ty = Math.floor(uvy3 * tiles);\" line155=\"        const isWhite = ((tx + ty) &amp; 1) ? 1 : 0;\" line156=\"\" line157=\"        const baseBlack = 0.1;\" line158=\"        const baseWhite = 0.9;\" line159=\"        const base = isWhite ? baseWhite : baseBlack;\" line160=\"\" line161=\"        // --- 5. Recalculate radial distance *after* warp ---\" line162=\"        const dx22 = frag.x - u.resolution.x / 2;\" line163=\"        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\" line164=\"        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\" line165=\"\" line166=\"        // --- 6. Shimmer based on warped radial distance ---\" line167=\"        const shimmerPhase = distWarped * freq2 - u.time * speed2;\" line168=\"        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\" line169=\"\" line170=\"        // --- 7. Combine and clamp ---\" line171=\"        let L = base + shimmer;\" line172=\"        if (L &lt; 0) L = 0;\" line173=\"        if (L &gt; 1) L = 1;\" line174=\"\" line175=\"        return L;\" line176=\"    };\" line177=\"\" line178=\"    interface Ripple {\" line179=\"        origin: Shaders.Vec2;\" line180=\"        startTime: number;\" line181=\"\" line182=\"        // precomputed each frame\" line183=\"        age?: number;\" line184=\"        waveDist?: number;\" line185=\"    }\" line186=\"\" line187=\"    let ripples: Ripple[] = [];\" line188=\"\" line189=\"    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\" line190=\"        ripples.push({\" line191=\"            origin: new Shaders.Vec2(x, y),\" line192=\"            startTime: game.runtime() / 1000\" line193=\"        });\" line194=\"    })\" line195=\"\" line196=\"    game.onUpdate(() =&gt; {\" line197=\"        const now = game.runtime() / 1000;\" line198=\"        ripples = ripples.filter(r =&gt; now - r.startTime &lt; 5); // keep last 5s\" line199=\"\" line200=\"        // precompute per-ripple values once per frame\" line201=\"        for (const r of ripples) {\" line202=\"            r.age = now - r.startTime;\" line203=\"            r.waveDist = r.age * 40; // speed in px/sec\" line204=\"        }\" line205=\"    });\" line206=\"\" line207=\"    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\" line208=\"        const dx3 = frag.x - r.origin.x;\" line209=\"        const dy3 = frag.y - r.origin.y;\" line210=\"        const dist22 = dx3 * dx3 + dy3 * dy3;\" line211=\"\" line212=\"        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\" line213=\"        const diff = dist6 - (r.waveDist || 0);\" line214=\"\" line215=\"        // cull if pixel is far from wavefront\" line216=\"        if (Math.abs(diff) &gt; 40) return 0;\" line217=\"\" line218=\"        // simple triangular falloff instead of exp()\" line219=\"        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\" line220=\"\" line221=\"        // cheap oscillation (precompute freq/speed if needed)\" line222=\"        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\" line223=\"    }\" line224=\"\" line225=\"    const checkerWithRippleClick: Shaders.Shader = (frag, u) =&gt; {\" line226=\"        // --- Checkerboard base ---\" line227=\"        const uvx4 = frag.x / u.resolution.x;\" line228=\"        const uvy4 = frag.y / u.resolution.y;\" line229=\"        const scale2 = 10;\" line230=\"        const tx2 = Math.floor(uvx4 * scale2);\" line231=\"        const ty2 = Math.floor(uvy4 * scale2);\" line232=\"        const isWhite2 = ((tx2 + ty2) &amp; 1) ? 1 : 0;\" line233=\"        const base2 = isWhite2 ? 0.9 : 0.1;\" line234=\"\" line235=\"        // --- Accumulate ripple contributions ---\" line236=\"        let rippleSum = 0;\" line237=\"        for (let i = 0; i &lt; ripples.length &amp;&amp; i &lt; 4; i++) {\" line238=\"            rippleSum += rippleContribution(frag, ripples[i]);\" line239=\"        }\" line240=\"\" line241=\"        // combine (tune ripple strength)\" line242=\"        let L2 = base2 + rippleSum;\" line243=\"\" line244=\"        // clamp\" line245=\"        if (L2 &lt; 0) L2 = 0;\" line246=\"        if (L2 &gt; 1) L2 = 1;\" line247=\"\" line248=\"        return L2;\" line249=\"    };\" line250=\"\" line251=\"    // initDefaults()\" line252=\"    // setActiveProgram((uniforms, screen) =&gt; {\" line253=\"    //     runShader(checkerWithRipple, screen, uniforms);\" line254=\"    // })\" line255=\"}\" numlines=\"256\"></mutation></block></statement></block></xml>","main.ts":"namespace Shaders {\n    const exampleShader: Shader = (frag, u) => {\n        const x = frag.x / u.resolution.x;\n        const y = frag.y / u.resolution.y;\n\n        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);\n        return v > 0 ? 0.2 : 0.8;\n    };\n\n    const plasmaShader: Shaders.Shader = (frag, u) => {\n        // normalize coordinates\n        const nx = frag.x / u.resolution.x;\n        const ny = frag.y / u.resolution.y;\n\n        // combine multiple sine waves\n        const w =\n            Math.sin(nx * 10 + u.time) +\n            Math.sin((ny * 10) + u.time * 1.3) +\n            Math.sin((nx + ny) * 10 + u.time * 0.7);\n\n        // normalize to 0..1\n        const normalized = (w + 3) / 6;\n\n        // map to grayscale shade (1–15)\n        return normalized;\n    };\n\n    const rippleShader: Shaders.Shader = (frag, u) => {\n        const cx = frag.x - u.resolution.x / 2;\n        const cy = frag.y - u.resolution.y / 2;\n        const dist = Math.sqrt(cx * cx + cy * cy);\n\n        const a = Math.sin(dist * 0.1 - u.time * 2);\n        const normalized2 = (a + 1) / 2;\n\n        return normalized2;\n    };\n\n    const tunnelShader: Shaders.Shader = (frag, u) => {\n        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;\n        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;\n\n        const angle = Math.atan2(ny2, nx2);\n        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);\n        return (b + 1) / 2;\n    };\n\n    const checkerShader: Shaders.Shader = (frag, u) => {\n        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));\n\n        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;\n        return c ? 1.0 : 0.0;\n    };\n\n    const circlesShader: Shaders.Shader = (frag, u) => {\n        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;\n        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;\n\n        const dx = frag.x - cx2;\n        const dy = frag.y - cy2;\n        const dist3 = Math.sqrt(dx * dx + dy * dy);\n\n        const d = Math.sin(dist3 * 0.2 - u.time * 2);\n        return (d + 1) / 2;\n    };\n\n    const marbleShader: Shaders.Shader = (frag, u) => {\n        const nx3 = frag.x / u.resolution.x;\n        const ny3 = frag.y / u.resolution.y;\n\n        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));\n        return (e + 1) / 2;\n    };\n\n    const marbleWithWobble: Shaders.Shader = (frag, u) => {\n        // normalized UVs 0..1\n        let uvx = frag.x / u.resolution.x;\n        let uvy = frag.y / u.resolution.y;\n\n        // warp Y coordinate\n        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;\n\n        // base marble pattern\n        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));\n\n        // GLSL does (v + 1)/2 to map -1..1 → 0..1\n        return (f + 1.0) * 0.5;\n    };\n\n    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {\n        // center coords\n        const cx3 = frag.x - u.resolution.x / 2;\n        const cy3 = frag.y - u.resolution.y / 2;\n        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);\n\n        // ripple parameters\n        const freq = 0.1;     // wave spacing\n        const speed = 4.0;    // animation speed\n        const baseAmp = 0.05; // base amplitude\n\n        // damping: amplitude decays with distance\n        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor\n\n        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;\n\n        // normalized UVs\n        const uvx2 = frag.x / u.resolution.x;\n        let uvy2 = frag.y / u.resolution.y;\n\n        // apply vertical ripple distortion\n        uvy2 += offset;\n\n        return new Shaders.Vec2(uvx2, uvy2);\n    }\n\n    const marbleWithRipple: Shaders.Shader = (frag, u) => {\n        // ripple-distorted UVs\n        const uv = rippleWarp(frag, u);\n\n        // marble pattern\n        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));\n\n        // normalize to 0..1\n        return (g + 1.0) * 0.5;\n    };\n\n    // Checkerboard + radial ripple (UV warp) + brightness shimmer\n    // Phases for warp and shimmer are split so you can tune alignment.\n\n    const checkerWithRipple: Shaders.Shader = (frag, u) => {\n        // --- 1. Distance from screen center ---\n        const dx2 = frag.x - u.resolution.x / 2;\n        const dy2 = frag.y - u.resolution.y / 2;\n        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n        // --- 2. Base ripple parameters ---\n        const freq2 = 0.12;                   // ripple spacing\n        const speed2 = 3.0;                   // animation speed\n        const damping2 = 1.0 / (1.0 + dist5 * 0.06);\n        const phase = dist5 * freq2 - u.time * speed2;\n\n        // --- 3. Warp the UVs (position ripple) ---\n        const uvx3 = frag.x / u.resolution.x;\n        let uvy3 = frag.y / u.resolution.y;\n\n        const warpAmp = 0.05;\n        const wave = Math.sin(phase);\n        uvy3 += wave * warpAmp * damping2;\n\n        // --- 4. Checkerboard pattern (sampled at warped UVs) ---\n        const tiles = 10;\n        const tx = Math.floor(uvx3 * tiles);\n        const ty = Math.floor(uvy3 * tiles);\n        const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n        const baseBlack = 0.1;\n        const baseWhite = 0.9;\n        const base = isWhite ? baseWhite : baseBlack;\n\n        // --- 5. Recalculate radial distance *after* warp ---\n        const dx22 = frag.x - u.resolution.x / 2;\n        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;\n        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);\n\n        // --- 6. Shimmer based on warped radial distance ---\n        const shimmerPhase = distWarped * freq2 - u.time * speed2;\n        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;\n\n        // --- 7. Combine and clamp ---\n        let L = base + shimmer;\n        if (L < 0) L = 0;\n        if (L > 1) L = 1;\n\n        return L;\n    };\n\n    interface Ripple {\n        origin: Shaders.Vec2;\n        startTime: number;\n\n        // precomputed each frame\n        age?: number;\n        waveDist?: number;\n    }\n\n    let ripples: Ripple[] = [];\n\n    browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {\n        ripples.push({\n            origin: new Shaders.Vec2(x, y),\n            startTime: game.runtime() / 1000\n        });\n    })\n\n    game.onUpdate(() => {\n        const now = game.runtime() / 1000;\n        ripples = ripples.filter(r => now - r.startTime < 5); // keep last 5s\n\n        // precompute per-ripple values once per frame\n        for (const r of ripples) {\n            r.age = now - r.startTime;\n            r.waveDist = r.age * 40; // speed in px/sec\n        }\n    });\n\n    function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {\n        const dx3 = frag.x - r.origin.x;\n        const dy3 = frag.y - r.origin.y;\n        const dist22 = dx3 * dx3 + dy3 * dy3;\n\n        const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple\n        const diff = dist6 - (r.waveDist || 0);\n\n        // cull if pixel is far from wavefront\n        if (Math.abs(diff) > 40) return 0;\n\n        // simple triangular falloff instead of exp()\n        const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);\n\n        // cheap oscillation (precompute freq/speed if needed)\n        return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;\n    }\n\n    const checkerWithRippleClick: Shaders.Shader = (frag, u) => {\n        // --- Checkerboard base ---\n        const uvx4 = frag.x / u.resolution.x;\n        const uvy4 = frag.y / u.resolution.y;\n        const scale2 = 10;\n        const tx2 = Math.floor(uvx4 * scale2);\n        const ty2 = Math.floor(uvy4 * scale2);\n        const isWhite2 = ((tx2 + ty2) & 1) ? 1 : 0;\n        const base2 = isWhite2 ? 0.9 : 0.1;\n\n        // --- Accumulate ripple contributions ---\n        let rippleSum = 0;\n        for (let i = 0; i < ripples.length && i < 4; i++) {\n            rippleSum += rippleContribution(frag, ripples[i]);\n        }\n\n        // combine (tune ripple strength)\n        let L2 = base2 + rippleSum;\n\n        // clamp\n        if (L2 < 0) L2 = 0;\n        if (L2 > 1) L2 = 1;\n\n        return L2;\n    };\n\n    // initDefaults()\n    // setActiveProgram((uniforms, screen) => {\n    //     runShader(checkerWithRipple, screen, uniforms);\n    // })\n}\n","README.md":" ","assets.json":"","types.ts":"namespace Shaders {\n    export interface Uniforms {\n        resolution: Vec2;\n        time: number;\n        frame: number;\n        mouse?: Vec2;\n    }\n\n    export type MainProgram = (uniforms: Uniforms, target: Image) => void\n\n    export type Shader = (\n        fragCoord: Vec2,\n        uniforms: Uniforms\n    ) => number;\n\n    export interface color {\n        shade: number\n    }\n\n    export class Color implements color {\n        private static lut: number[] = [];\n        private static lutSize: number = 0;\n\n        constructor(public shade: number) { }\n\n        static initLUT(size: number = 128): void {\n            this.lutSize = size;\n            this.lut = [];\n            for (let i = 0; i < size; i++) {\n                const v = i / (size - 1);\n                const raw = Math.floor(v * 14) + 1;\n                const shade = 16 - raw;\n                this.lut.push(shade);\n            }\n        }\n\n        static fromFloat(luminance: number): Color {\n            const idx = Math.max(0, Math.min(this.lutSize - 1, Math.floor(luminance * (this.lutSize - 1))));\n            return new Color(this.lut[idx]);\n        }\n\n        toFloat(): number {\n            const raw = 16 - this.shade;\n            return (raw - 1) / 14;\n        }\n    }\n\n    export interface vec2<T> {\n        x: T,\n        y: T\n    }\n\n    export class Vec2 implements vec2<number> {\n        constructor(public x: number, public y: number) { }\n\n        add(v: Vec2) { return new Vec2(this.x + v.x, this.y + v.y); }\n        sub(v: Vec2) { return new Vec2(this.x - v.x, this.y - v.y); }\n        mul(f: number) { return new Vec2(this.x * f, this.y * f); }\n        div(f: number) { return new Vec2(this.x / f, this.y / f); }\n\n        dot(v: Vec2) { return this.x * v.x + this.y * v.y; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.div(len) : new Vec2(0, 0);\n        }\n    }\n\n    export class Vec3 {\n        constructor(public x: number, public y: number, public z: number) { }\n\n        add(v: Vec3) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }\n        sub(v: Vec3) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }\n        mul(f: number) { return new Vec3(this.x * f, this.y * f, this.z * f); }\n        dot(v: Vec3) { return this.x * v.x + this.y * v.y + this.z * v.z; }\n        length() { return Math.sqrt(this.dot(this)); }\n        normalize() {\n            const len = this.length();\n            return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 0);\n        }\n    }\n}","functions.ts":"namespace Shaders {\n    export function initLUT(size = 128) {\n        Color.initLUT(size);\n    }\n\n    export function initDefaults() {\n        initLUT()\n    }\n\n    export function runShader(\n        shader: Shader,\n        img: Image,\n        uniforms: Uniforms\n    ) {\n        for (let y = 0; y < uniforms.resolution.y; y++) {\n            for (let x = 0; x < uniforms.resolution.x; x++) {\n                const luminance = shader(new Vec2(x, y), uniforms);\n                const color = Color.fromFloat(luminance)\n                img.setPixel(x, y, color.shade);\n            }\n        }\n    }\n\n    const screen = image.create(160, 120)\n    let frame = 0;\n    let uniforms: Uniforms = {\n        resolution: new Vec2(screen.width, screen.height),\n        time: game.runtime() / 1000,\n        frame: frame++\n    };\n\n    let activeProgram: MainProgram = null;\n    \n    export function setActiveProgram(program: MainProgram): void {\n        activeProgram = program\n    }\n    \n    game.onUpdate(() => {\n        uniforms = {\n            resolution: new Vec2(screen.width, screen.height),\n            time: game.runtime() / 1000,\n            frame: frame++\n        };\n\n        if (activeProgram) {\n            activeProgram(uniforms, screen)\n        }\n\n        scene.setBackgroundImage(screen)\n    })\n}","water_sim.ts":"namespace WaterSim {\n    export const GW = 60;\n    export const GH = 45;\n    const FP = 256;\n\n    // Damping\n    const DAMP_NUM = 230;\n    const DAMP_SHIFT = 8;\n\n    // Pre-allocate buffers as plain number[] with fixed size\n    const SIZE = GW * GH;\n    let A: number[] = [];\n    let B: number[] = [];\n    let C: number[] = [];\n\n    // Manual initialization (no `new Array`)\n    export function init() {\n        A = [];\n        B = [];\n        C = [];\n        for (let i = 0; i < SIZE; i++) {\n            A.push(0);\n            B.push(0);\n            C.push(0);\n        }\n    }\n\n    let prev: number[];\n    let cur: number[];\n    let nextB: number[];\n\n    export function reset() {\n        init();\n        prev = A;\n        cur = B;\n        nextB = C;\n    }\n\n    function idx(x: number, y: number) { return y * GW + x; }\n\n    // Splash at screen coords\n    export function splash(sx: number, sy: number, strength = 1, radiusPx = 10) {\n        const gx = Math.idiv(sx * GW, screen.width);\n        const gy = Math.idiv(sy * GH, screen.height);\n        const r = Math.max(1, Math.idiv(radiusPx * GW, screen.width));\n\n        const amp = (strength * FP) | 0;\n\n        for (let y = Math.max(1, gy - r); y <= Math.min(GH - 2, gy + r); y++) {\n            for (let x = Math.max(1, gx - r); x <= Math.min(GW - 2, gx + r); x++) {\n                const dx = x - gx;\n                const dy = y - gy;\n                const d2 = dx * dx + dy * dy;\n                if (d2 <= r * r) {\n                    cur[idx(x, y)] += amp;\n                }\n            }\n        }\n    }\n\n    export function step() {\n        for (let y = 1; y < GH - 1; y++) {\n            const yW = y * GW;\n            for (let x = 1; x < GW - 1; x++) {\n                const i = yW + x;\n                const sum = cur[i - 1] + cur[i + 1] + cur[i - GW] + cur[i + GW];\n                let n = (sum >> 1) - prev[i];\n                n = (n * DAMP_NUM) >> DAMP_SHIFT;\n                nextB[i] = n;\n            }\n        }\n        // rotate\n        const tmp = prev; prev = cur; cur = nextB; nextB = tmp;\n    }\n\n    export function sampleHeight(sx: number, sy: number): number {\n        const gx = sx * (GW - 1) / (screen.width - 1);\n        const gy = sy * (GH - 1) / (screen.height - 1);\n\n        const x0 = Math.max(0, Math.min(GW - 2, Math.floor(gx)));\n        const y0 = Math.max(0, Math.min(GH - 2, Math.floor(gy)));\n        const tx = gx - x0;\n        const ty = gy - y0;\n\n        const i00 = cur[idx(x0, y0)];\n        const i10 = cur[idx(x0 + 1, y0)];\n        const i01 = cur[idx(x0, y0 + 1)];\n        const i11 = cur[idx(x0 + 1, y0 + 1)];\n\n        const a = i00 * (1 - tx) + i10 * tx;\n        const b = i01 * (1 - tx) + i11 * tx;\n        const hFP = a * (1 - ty) + b * ty;\n\n        return (hFP / FP) / 2;\n    }\n}\n\nWaterSim.reset();\n\nlet mouse = new Shaders.Vec2(80, 60)\nlet rippleOrigin = new Shaders.Vec2(80, 60)\n\nlet boat = assets.image`boat_0`\nconsole.log(boat)\n\n// let boat = sprites.create(assets.image`boat-0`)\n\nbrowserEvents.onMouseMove(function(x: number, y: number) {\n    mouse.x = x\n    mouse.y = y\n    if (browserEvents.MouseLeft.isPressed()) {\n        WaterSim.splash(rippleOrigin.x, rippleOrigin.y, 1.0, 4);\n    }\n})\n\ngame.onUpdate(function () {\n    WaterSim.step();\n    const move = mouse.sub(rippleOrigin).normalize().mul(5)\n    rippleOrigin = rippleOrigin.add(move)\n\n});\n\nconst checkerWaterShader: Shaders.Shader = (frag, u) => {\n    const h = WaterSim.sampleHeight(frag.x, frag.y);\n\n    const uvx = frag.x / u.resolution.x;\n    let uvy = frag.y / u.resolution.y + h * 0.15;\n\n    const tiles = 10;\n    const tx = Math.floor(uvx * tiles);\n    const ty = Math.floor(uvy * tiles);\n    const isWhite = ((tx + ty) & 1) ? 1 : 0;\n\n    let L = isWhite ? 0.9 : 0.1;\n    L += h * 0.5;\n\n    if (L < 0) L = 0;\n    if (L > 1) L = 1;\n\n    return L;\n};\n\nShaders.initDefaults()\nShaders.setActiveProgram((uniforms, screen) => {\n    Shaders.runShader(checkerWaterShader, screen, uniforms);\n})","images.g.jres":"{\n    \"image4\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAADuDgAAAAAA4KruAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK6uzgAAAAAArq7OAAAAAACurs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAK7q7AAAAAAA4O4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-270\"\n    },\n    \"image5\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODOAAAAAAAAruoMAAAAAOCqqs4AAAAArqqq6gwAAOCqqqrqDAAAruquqs4MAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAK6qqs4MAAAArqrqzAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-45\"\n    },\n    \"image6\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqzAAAAACuqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgwAAOCqqqrqDAAAAK6qquoMAAAA4KqqzgAAAAAAruoMAAAAAADgzgAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-315\"\n    },\n    \"image7\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAODuzgAAAAAArqrqDAAAAOCqquoMAAAArqqq6gwAAOCqqqrqDAAAruquqs4AAOCq6q7qzAAArqqqqs4MAACuqqrqzAAAAOCqqs4MAAAAAK7qzAAAAAAA4M4MAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-225\"\n    },\n    \"image8\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAADgzgwAAAAAAK7qzAAAAADgqqrODAAAAK6qqurMAAAArqqqqs4MAADgququ6swAAACu6q6qzgAAAOCqqqrqDAAAAK6qquoMAAAA4Kqq6gwAAAAArqrqDAAAAADg7s4AAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-135\"\n    },\n    \"image3\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAODuDgAAAAAArursAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACurs4AAAAAAK6uzgAAAAAArq7OAAAAAACuqs4AAAAAAK6qzgAAAAAArqrOAAAAAACuqs4AAAAAAOCq7gAAAAAAAO4OAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-90\"\n    },\n    \"image2\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7s4AAK6qqqqq6gwArqqqqqqqDgCuququqqoOAK6q6q6qqg4ArqqqqqqqDgCuqqqqquoMAODu7u7uzgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat-180\"\n    },\n    \"image1\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg7u7u7s4AAK6qqqqq6gzgqqqqqqrqDOCqquququoM4Kqq6q6q6gzgqqqqqqrqDACuqqqqquoMAODu7u7uzgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"boat_0\"\n    },\n    \"anim1\": {\n        \"namespace\": \"myAnimations\",\n        \"id\": \"anim1\",\n        \"mimeType\": \"application/mkcd-animation\",\n        \"data\": \"NTAwMDEwMDAxMDAwMDUwMDAwMDAwMDYwNjYwMDAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjY2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2MDYwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDA2NjAwNjAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjAwNjAwMDAwMDAwMDAwMGMwNjAwMDAwMDAwMDAwMDBjMDA2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjAwMDYwMDAwMDAwMGMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDYwMDYwMDAwMDAwMDAwMDBjMDYwMDAwMDAwMDAwMDAwYzAwNjAwMDAwMDAwMDAwMGMwNjYwMDAwMDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzA2NjY2MDYwMDAwMDAwMGMwNjYwNjAwMDAwMDAwMDBjMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2MDY2MDAwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMGMwMDYwMDAwMDAwMDAwMDBjMDY2MDAwMDAwMDAwMDAwYzA2NjA2MDAwMDAwMDAwMGMwNjY2NjA2MDAwMDAwMDBjMDY2NjYwMDAwMDAwMDAwYzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\",\n        \"displayName\": \"myAnim\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"shaders\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"browser-events\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"types.ts\",\n        \"functions.ts\",\n        \"water_sim.ts\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"palette\": [\n        \"#000000\",\n        \"#FFFFFF\",\n        \"#EDEDED\",\n        \"#DBDBDB\",\n        \"#C8C8C8\",\n        \"#B6B6B6\",\n        \"#A4A4A4\",\n        \"#929292\",\n        \"#808080\",\n        \"#6D6D6D\",\n        \"#5B5B5B\",\n        \"#494949\",\n        \"#373737\",\n        \"#242424\",\n        \"#121212\",\n        \"#000000\"\n    ]\n}\n"}}],"shares":[],"lastSaveTime":1759592767752}