<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="CeZj~77;D+bAe,cf|U}p" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="/_YqpP5/WrvEZxANMvL,"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace Shaders {" line1="    const exampleShader: Shader = (frag, u) =&gt; {" line2="        const x = frag.x / u.resolution.x;" line3="        const y = frag.y / u.resolution.y;" line4="" line5="        const v = Math.sin(x * 10 + u.time) + Math.cos(y * 10 - u.time);" line6="        return v &gt; 0 ? 0.2 : 0.8;" line7="    };" line8="" line9="    const plasmaShader: Shaders.Shader = (frag, u) =&gt; {" line10="        // normalize coordinates" line11="        const nx = frag.x / u.resolution.x;" line12="        const ny = frag.y / u.resolution.y;" line13="" line14="        // combine multiple sine waves" line15="        const w =" line16="            Math.sin(nx * 10 + u.time) +" line17="            Math.sin((ny * 10) + u.time * 1.3) +" line18="            Math.sin((nx + ny) * 10 + u.time * 0.7);" line19="" line20="        // normalize to 0..1" line21="        const normalized = (w + 3) / 6;" line22="" line23="        // map to grayscale shade (1–15)" line24="        return normalized;" line25="    };" line26="" line27="    const rippleShader: Shaders.Shader = (frag, u) =&gt; {" line28="        const cx = frag.x - u.resolution.x / 2;" line29="        const cy = frag.y - u.resolution.y / 2;" line30="        const dist = Math.sqrt(cx * cx + cy * cy);" line31="" line32="        const a = Math.sin(dist * 0.1 - u.time * 2);" line33="        const normalized2 = (a + 1) / 2;" line34="" line35="        return normalized2;" line36="    };" line37="" line38="    const tunnelShader: Shaders.Shader = (frag, u) =&gt; {" line39="        const nx2 = (frag.x - u.resolution.x / 2) / u.resolution.x;" line40="        const ny2 = (frag.y - u.resolution.y / 2) / u.resolution.y;" line41="" line42="        const angle = Math.atan2(ny2, nx2);" line43="        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);" line44="" line45="        const b = Math.sin(10 * dist2 - u.time * 3 + angle * 5);" line46="        return (b + 1) / 2;" line47="    };" line48="" line49="    const checkerShader: Shaders.Shader = (frag, u) =&gt; {" line50="        const scale = Math.clamp(1, 100, Math.abs(100 * Math.sin(u.time / 5)));" line51="" line52="        const c = (Math.floor(frag.x / scale) + Math.floor(frag.y / scale)) % 2;" line53="        return c ? 1.0 : 0.0;" line54="    };" line55="" line56="    const circlesShader: Shaders.Shader = (frag, u) =&gt; {" line57="        const cx2 = u.resolution.x / 2 + Math.sin(u.time) * 40;" line58="        const cy2 = u.resolution.y / 2 + Math.cos(u.time) * 30;" line59="" line60="        const dx = frag.x - cx2;" line61="        const dy = frag.y - cy2;" line62="        const dist3 = Math.sqrt(dx * dx + dy * dy);" line63="" line64="        const d = Math.sin(dist3 * 0.2 - u.time * 2);" line65="        return (d + 1) / 2;" line66="    };" line67="" line68="    const marbleShader: Shaders.Shader = (frag, u) =&gt; {" line69="        const nx3 = frag.x / u.resolution.x;" line70="        const ny3 = frag.y / u.resolution.y;" line71="" line72="        const e = Math.sin(nx3 * 10 + Math.sin(ny3 * 10 + u.time));" line73="        return (e + 1) / 2;" line74="    };" line75="" line76="    const marbleWithWobble: Shaders.Shader = (frag, u) =&gt; {" line77="        // normalized UVs 0..1" line78="        let uvx = frag.x / u.resolution.x;" line79="        let uvy = frag.y / u.resolution.y;" line80="" line81="        // warp Y coordinate" line82="        uvy += Math.sin(uvx * 10.0 + u.time) * 0.05;" line83="" line84="        // base marble pattern" line85="        const f = Math.sin(uvx * 10.0 + Math.sin(uvy * 10.0 + u.time));" line86="" line87="        // GLSL does (v + 1)/2 to map -1..1 → 0..1" line88="        return (f + 1.0) * 0.5;" line89="    };" line90="" line91="    function rippleWarp(frag: Shaders.Vec2, u: Shaders.Uniforms): Shaders.Vec2 {" line92="        // center coords" line93="        const cx3 = frag.x - u.resolution.x / 2;" line94="        const cy3 = frag.y - u.resolution.y / 2;" line95="        const dist4 = Math.sqrt(cx3 * cx3 + cy3 * cy3);" line96="" line97="        // ripple parameters" line98="        const freq = 0.1;     // wave spacing" line99="        const speed = 4.0;    // animation speed" line100="        const baseAmp = 0.05; // base amplitude" line101="" line102="        // damping: amplitude decays with distance" line103="        const damping = 1.0 / (1.0 + dist4 * 0.01); // tweak factor" line104="" line105="        const offset = Math.sin(dist4 * freq - u.time * speed) * baseAmp * damping;" line106="" line107="        // normalized UVs" line108="        const uvx2 = frag.x / u.resolution.x;" line109="        let uvy2 = frag.y / u.resolution.y;" line110="" line111="        // apply vertical ripple distortion" line112="        uvy2 += offset;" line113="" line114="        return new Shaders.Vec2(uvx2, uvy2);" line115="    }" line116="" line117="    const marbleWithRipple: Shaders.Shader = (frag, u) =&gt; {" line118="        // ripple-distorted UVs" line119="        const uv = rippleWarp(frag, u);" line120="" line121="        // marble pattern" line122="        const g = Math.sin(uv.x * 10.0 + Math.sin(uv.y * 10.0 + u.time));" line123="" line124="        // normalize to 0..1" line125="        return (g + 1.0) * 0.5;" line126="    };" line127="" line128="    // Checkerboard + radial ripple (UV warp) + brightness shimmer" line129="    // Phases for warp and shimmer are split so you can tune alignment." line130="" line131="    const checkerWithRipple: Shaders.Shader = (frag, u) =&gt; {" line132="        // --- 1. Distance from screen center ---" line133="        const dx2 = frag.x - u.resolution.x / 2;" line134="        const dy2 = frag.y - u.resolution.y / 2;" line135="        const dist5 = Math.sqrt(dx2 * dx2 + dy2 * dy2);" line136="" line137="        // --- 2. Base ripple parameters ---" line138="        const freq2 = 0.12;                   // ripple spacing" line139="        const speed2 = 3.0;                   // animation speed" line140="        const damping2 = 1.0 / (1.0 + dist5 * 0.06);" line141="        const phase = dist5 * freq2 - u.time * speed2;" line142="" line143="        // --- 3. Warp the UVs (position ripple) ---" line144="        const uvx3 = frag.x / u.resolution.x;" line145="        let uvy3 = frag.y / u.resolution.y;" line146="" line147="        const warpAmp = 0.05;" line148="        const wave = Math.sin(phase);" line149="        uvy3 += wave * warpAmp * damping2;" line150="" line151="        // --- 4. Checkerboard pattern (sampled at warped UVs) ---" line152="        const tiles = 10;" line153="        const tx = Math.floor(uvx3 * tiles);" line154="        const ty = Math.floor(uvy3 * tiles);" line155="        const isWhite = ((tx + ty) &amp; 1) ? 1 : 0;" line156="" line157="        const baseBlack = 0.1;" line158="        const baseWhite = 0.9;" line159="        const base = isWhite ? baseWhite : baseBlack;" line160="" line161="        // --- 5. Recalculate radial distance *after* warp ---" line162="        const dx22 = frag.x - u.resolution.x / 2;" line163="        const dy22 = (uvy3 * u.resolution.y) - u.resolution.y / 2;" line164="        const distWarped = Math.sqrt(dx22 * dx22 + dy22 * dy22);" line165="" line166="        // --- 6. Shimmer based on warped radial distance ---" line167="        const shimmerPhase = distWarped * freq2 - u.time * speed2;" line168="        const shimmer = Math.sin(shimmerPhase) * 0.5 * damping2;" line169="" line170="        // --- 7. Combine and clamp ---" line171="        let L = base + shimmer;" line172="        if (L &lt; 0) L = 0;" line173="        if (L &gt; 1) L = 1;" line174="" line175="        return L;" line176="    };" line177="" line178="    // interface Ripple {" line179="    //     origin: Shaders.Vec2;" line180="    //     startTime: number;" line181="" line182="    //     // precomputed each frame" line183="    //     age?: number;" line184="    //     waveDist?: number;" line185="    // }" line186="" line187="    // let ripples: Ripple[] = [];" line188="" line189="    // browserEvents.MouseLeft.onEvent(browserEvents.MouseButtonEvent.Pressed, function(x: number, y: number) {" line190="    //     ripples.push({" line191="    //         origin: new Shaders.Vec2(x, y)," line192="    //         startTime: game.runtime() / 1000" line193="    //     });" line194="    // })" line195="" line196="    // game.onUpdate(() =&gt; {" line197="    //     const now = game.runtime() / 1000;" line198="    //     ripples = ripples.filter((r) =&gt; {" line199="    //         return now - r.startTime &lt; 5" line200="    //     }); // keep last 5s" line201="" line202="    //     // precompute per-ripple values once per frame" line203="    //     for (const r of ripples) {" line204="    //         r.age = now - r.startTime;" line205="    //         r.waveDist = r.age * 40; // speed in px/sec" line206="    //     }" line207="    // });" line208="" line209="    // function rippleContribution(frag: Shaders.Vec2, r: Ripple): number {" line210="    //     const dx3 = frag.x - r.origin.x;" line211="    //     const dy3 = frag.y - r.origin.y;" line212="    //     const dist22 = dx3 * dx3 + dy3 * dy3;" line213="" line214="    //     const dist6 = Math.sqrt(dist22); // one sqrt only if near the ripple" line215="    //     const diff = dist6 - (r.waveDist || 0);" line216="" line217="    //     // cull if pixel is far from wavefront" line218="    //     if (Math.abs(diff) &gt; 40) return 0;" line219="" line220="    //     // simple triangular falloff instead of exp()" line221="    //     const ring = Math.max(0, 1 - Math.abs(diff) * 0.05);" line222="" line223="    //     // cheap oscillation (precompute freq/speed if needed)" line224="    //     return Math.sin(dist6 * 0.25 - (r.age || 0) * 4) * ring * 0.5;" line225="    // }" line226="" line227="    // const checkerWithRippleClick: Shaders.Shader = (frag, u) =&gt; {" line228="    //     // --- Checkerboard base ---" line229="    //     const uvx4 = frag.x / u.resolution.x;" line230="    //     const uvy4 = frag.y / u.resolution.y;" line231="    //     const scale2 = 10;" line232="    //     const tx2 = Math.floor(uvx4 * scale2);" line233="    //     const ty2 = Math.floor(uvy4 * scale2);" line234="    //     const isWhite2 = ((tx2 + ty2) &amp; 1) ? 1 : 0;" line235="    //     const base2 = isWhite2 ? 0.9 : 0.1;" line236="" line237="    //     // --- Accumulate ripple contributions ---" line238="    //     let rippleSum = 0;" line239="    //     for (let i = 0; i &lt; ripples.length; i++) {" line240="    //         rippleSum += rippleContribution(frag, ripples[i]);" line241="    //     }" line242="" line243="    //     // combine (tune ripple strength)" line244="    //     let L2 = base2 + rippleSum;" line245="" line246="    //     // clamp" line247="    //     if (L2 &lt; 0) L2 = 0;" line248="    //     if (L2 &gt; 1) L2 = 1;" line249="" line250="    //     return L2;" line251="    // };" line252="" line253="    // initDefaults()" line254="    // setActiveProgram((uniforms, screen) =&gt; {" line255="    //     runShader(checkerWithRipple, screen, uniforms);" line256="    // })" line257="}" numlines="258"></mutation></block></statement></block></xml>